<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>前端面试题 | sssc &amp; 博客</title><meta name="author" content="sssc"><meta name="copyright" content="sssc"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="项目 项目的上线流程项目立项-&gt;编写需求文档-&gt;需求评审-&gt;原型图-&gt;原型图评审-&gt;项目分工-&gt;项目开发-&gt;项目测试-&gt;项目构建-&gt;项目上线 项目性能优化 代码优化：使用最新的JavaScript语法、编写优化的CSS样式、尽量减少DOM操作、使用缓存等技术，来优化代码逻辑，提高代码执行效率和页面响应速度。 异步加载：对于耗时较长的资源（如大">
<meta property="og:type" content="article">
<meta property="og:title" content="前端面试题">
<meta property="og:url" content="http://example.com/2023/07/20/%E9%9D%A2%E8%AF%95%E9%A2%98/index.html">
<meta property="og:site_name" content="sssc &amp; 博客">
<meta property="og:description" content="项目 项目的上线流程项目立项-&gt;编写需求文档-&gt;需求评审-&gt;原型图-&gt;原型图评审-&gt;项目分工-&gt;项目开发-&gt;项目测试-&gt;项目构建-&gt;项目上线 项目性能优化 代码优化：使用最新的JavaScript语法、编写优化的CSS样式、尽量减少DOM操作、使用缓存等技术，来优化代码逻辑，提高代码执行效率和页面响应速度。 异步加载：对于耗时较长的资源（如大">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://example.com/img/avatar.png">
<meta property="article:published_time" content="2023-07-20T15:18:42.000Z">
<meta property="article:modified_time" content="2023-07-21T03:20:54.250Z">
<meta property="article:author" content="sssc">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/img/avatar.png"><link rel="shortcut icon" href="/img/avatar.png"><link rel="canonical" href="http://example.com/2023/07/20/%E9%9D%A2%E8%AF%95%E9%A2%98/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"top_n_per_article":1,"unescape":false,"languages":{"hits_empty":"找不到您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: undefined,
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '前端面试题',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2023-07-21 11:20:54'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
    win.getCSS = (url,id = false) => new Promise((resolve, reject) => {
      const link = document.createElement('link')
      link.rel = 'stylesheet'
      link.href = url
      if (id) link.id = id
      link.onerror = reject
      link.onload = link.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        link.onload = link.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(link)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.3.0"><link rel="alternate" href="/atom.xml" title="sssc & 博客" type="application/atom+xml">
</head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/loading.gif" data-original="/img/avatar.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">5</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">0</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><hr class="custom-hr"/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fa fa-graduation-cap"></i><span> 博文</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/categories/"><i class="fa-fw fa fa-archive"></i><span> 分类</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></li><li><a class="site-page child" href="/archives/"><i class="fa-fw fa fa-folder-open"></i><span> 归档</span></a></li></ul></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 生活</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/photos/"><i class="fa-fw fa fa-camera-retro"></i><span> 相册</span></a></li><li><a class="site-page child" href="/music/"><i class="fa-fw fa fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 影视</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/comment/"><i class="fa-fw fa fa-paper-plane"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于笔者</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('/img/preview.jpg')"><nav id="nav"><span id="blog-info"><a href="/" title="sssc &amp; 博客"><span class="site-name">sssc &amp; 博客</span></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search" href="javascript:void(0);"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fa fa-graduation-cap"></i><span> 博文</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/categories/"><i class="fa-fw fa fa-archive"></i><span> 分类</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></li><li><a class="site-page child" href="/archives/"><i class="fa-fw fa fa-folder-open"></i><span> 归档</span></a></li></ul></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 生活</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/photos/"><i class="fa-fw fa fa-camera-retro"></i><span> 相册</span></a></li><li><a class="site-page child" href="/music/"><i class="fa-fw fa fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 影视</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/comment/"><i class="fa-fw fa fa-paper-plane"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于笔者</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">前端面试题</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-07-20T15:18:42.000Z" title="发表于 2023-07-20 23:18:42">2023-07-20</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-07-21T03:20:54.250Z" title="更新于 2023-07-21 11:20:54">2023-07-21</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="前端面试题"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><p><a name="bqM1b"></a></p>
<h2 id="项目"><a href="#项目" class="headerlink" title="项目"></a>项目</h2><p><a name="Ox9A0"></a></p>
<h3 id="项目的上线流程"><a href="#项目的上线流程" class="headerlink" title="项目的上线流程"></a>项目的上线流程</h3><p>项目立项-&gt;编写需求文档-&gt;需求评审-&gt;原型图-&gt;原型图评审-&gt;项目分工-&gt;项目开发-&gt;项目测试-&gt;项目构建-&gt;项目上线<br><a name="V9K5h"></a></p>
<h3 id="项目性能优化"><a href="#项目性能优化" class="headerlink" title="项目性能优化"></a>项目性能优化</h3><ol>
<li>代码优化：使用最新的JavaScript语法、编写优化的CSS样式、尽量减少DOM操作、使用缓存等技术，来优化代码逻辑，提高代码执行效率和页面响应速度。</li>
<li>异步加载：对于耗时较长的资源（如大型的JS脚本、CSS文件、图片等），可以使用异步加载技术，将资源按需加载，避免首次加载时出现卡顿。</li>
<li>懒加载：采用懒加载技术，将非首屏必要的组件、图片等延迟加载，以减小首屏加载时间。</li>
<li>前端缓存：通过合理的缓存策略，缓存静态资源（如图片、纯CSS等），减少服务器的请求压力。利用浏览器缓存机制，可以使得部分文件不需要重复加载和传输，从而减少页面请求时间。</li>
<li>图片优化：对于图片，可以进行多种优化策略，包括压缩图片、使用WebP格式图片、使用图片CDN等，以减小图片的大小和数量，从而提升网页的加载速度。</li>
<li>构建优化：使用工具如Webpack、Parcel等，对JS、CSS、图片等进行打包，且使用开发模式和生产模式的两个配置文件，最终构建出一个精简且高效的代码库。</li>
<li>CDN加速：静态资源通过CDN方式进行加载，可以减少对于服务器的请求压力，提高网页加载速度。</li>
<li>代码检查和优化：在项目开发过程中，使用工具如ESLint、Prettier等检查代码质量和风格，编写性能优良、健壮的代码。<br><a name="YN50H"></a></li>
</ol>
<h3 id="MVVM理解"><a href="#MVVM理解" class="headerlink" title="MVVM理解"></a>MVVM理解</h3><p>MMVVM 是一种前端架构模式，其中 MVVM 代表了 Model-View-ViewModel。<br />Model 表示数据模型层，即应用程序中的业务数据和规则。<br />View 表示视图层，即用户界面。<br />ViewModel 将 View 和 Model 进行绑定，它充当着数据转换器，将模型数据转换成视图中所需要的数据，同时也将视图中所产生的事件和状态转换为模型数据。<br />MVVM 的核心思想是数据绑定，而这是通过 ViewModel 来实现的。ViewModel 监听 Model 中数据的变化，并将这些变化同步到视图上，同时也监听视图中用户的交互事件，并将这些事件转化为 Model 中数据的变化。<br />在 MVVM 模式中，View 很少直接与 Model 进行交互，而是通过 ViewModel 进行间接交互。这样做的好处是，可以让开发者专注于 UI 层的开发而无需关心数据模型层的复杂逻辑，同时也提高了代码的可重用性和可维护性。<br><a name="n2mxA"></a></p>
<h3 id="MVC理解"><a href="#MVC理解" class="headerlink" title="MVC理解"></a>MVC理解</h3><p>MVC 是一种前端架构模式，其中 MVC 代表了 Model-View-Controller。<br />Model 表示数据模型层，即应用程序中的业务数据和规则。<br />View 表示视图层，即用户界面。<br />Controller 充当着连接 View 和 Model 的桥梁，它处理用户输入、控制数据流向 Model，同时更新 View。<br />MVC 的核心思想是分离关注点，将应用程序的不同功能（数据存储、业务逻辑、用户界面）分别放置在不同的组件（Model、View、Controller）中进行处理。这样做的好处是，可以让不同的组件相对独立地开发、测试和维护，提高了代码的可读性和可维护性。<br />在 MVC 模式中，View 通常会触发事件（比如用户点击按钮），然后将事件传递给 Controller 进行处理。Controller 处理完事件之后，可能需要对 Model 进行操作，比如获取或更新数据。当 Model 的状态发生变化时，Controller 获取这些变化并更新 View，用户最终看到的就是更新后的界面。<br><a name="VhSHY"></a></p>
<h3 id="MVC和MVVM的区别"><a href="#MVC和MVVM的区别" class="headerlink" title="MVC和MVVM的区别"></a>MVC和MVVM的区别</h3><ol>
<li>视图和数据绑定方向不同：MVC 中视图（View）与控制器（Controller）是双向绑定的，视图对模型（Model）的变化可以更新自己，同时控制器也可以通过视图更新模型。而在 MVVM 中，视图（View）与视图模型（ViewModel）之间是单向绑定的，视图模型维护了模型（Model）的状态和行为，并向视图公开属性和命令，当模型发生变化时，视图模型会自动更新视图。</li>
<li>应用场景不同：MVC 更适合大型应用场景，其中模型（Model）和控制器（Controller）可以独立开发和测试，相互之间较为独立。而 MVVM 则更适合于数据绑定较为复杂的场景，比如表单处理、页面渲染等。</li>
<li>数据的处理方式不同：在 MVC 中，控制器（Controller）负责业务逻辑处理和数据的获取、更新，将处理好的数据传递给视图（View）进行渲染。而在 MVVM 中，大部分数据处理逻辑都放在了视图模型（ViewModel）中，视图模型负责将数据绑定到视图上，视图只需要关注如何显示数据即可。<br><a name="HMgr4"></a></li>
</ol>
<h3 id="微信小程序的双向绑定和Vue的双向绑定哪里不一样"><a href="#微信小程序的双向绑定和Vue的双向绑定哪里不一样" class="headerlink" title="微信小程序的双向绑定和Vue的双向绑定哪里不一样"></a>微信小程序的双向绑定和Vue的双向绑定哪里不一样</h3><ol>
<li>语法不同：微信小程序使用的是 <code>bindinput</code> 绑定事件来实现双向绑定，而 Vue 使用的是 <code>v-model</code> 指令。</li>
<li>数据流动不同：微信小程序的双向绑定是通过事件传递数据的方式实现的，而 Vue 的双向绑定是通过数据劫持实现的。</li>
<li>作用域不同：微信小程序的双向绑定只能在组件内部使用，而 Vue 的双向绑定可以在组件之间进行数据传递。</li>
<li>性能不同：微信小程序的双向绑定性能较差，因为每次输入都会触发一次事件传递数据，而 Vue 的双向绑定通过数据劫持实现，性能较高。</li>
</ol>
<p>总的来说，微信小程序的双向绑定和 Vue 的双向绑定虽然都是实现数据的双向绑定，但是实现方式、作用域和性能等方面都有所不同。<br><a name="i8et7"></a></p>
<h3 id="沙箱隔离"><a href="#沙箱隔离" class="headerlink" title="沙箱隔离"></a>沙箱隔离</h3><p>沙箱隔离是一种安全机制，它通过将应用程序或进程运行在一个隔离的环境中，来避免应用程序或进程对系统的恶意影响。在沙箱环境中，应用程序或进程无法访问系统资源，如文件系统、网络、注册表等。这样可以保护系统免受恶意软件的攻击，同时也可以保护应用程序或进程免受系统资源的干扰。沙箱隔离常用于虚拟化技术、安全软件、浏览器等应用程序中。<br><a name="SH91i"></a></p>
<h3 id="虚拟列表是什么，项目中有哪些应用场景"><a href="#虚拟列表是什么，项目中有哪些应用场景" class="headerlink" title="虚拟列表是什么，项目中有哪些应用场景"></a>虚拟列表是什么，项目中有哪些应用场景</h3><p>前端虚拟列表是一种通过只渲染可视区域内的列表项，以减少页面元素渲染数量和提高渲染性能的技术。它通常应用于需要显示大量数据列表时，能够有效地优化性能并提升用户体验。<br />虚拟列表的实现方式主要有两种：</p>
<ol>
<li>基于滚动事件监听：根据当前滚动位置计算出可视区域内需要渲染的列表项，只对这些列表项进行渲染和更新，并使用占位元素来保持滚动条长度不变。</li>
<li>基于外部尺寸监听：在组件的渲染过程中，根据容器的尺寸计算出可视区域内需要渲染的列表项，只对这些列表项进行渲染和更新。</li>
</ol>
<p>虚拟列表的应用场景包括以下几个方面：</p>
<ol>
<li>需要显示大量数据列表时，例如网站的商品列表、音乐播放列表、聊天记录等。</li>
<li>对于复杂的列表项，需要避免重复创建和销毁的情况，例如需要渲染复杂的图形、交互式控件等。</li>
<li>在移动端等资源受限的情况下，需要优化性能和提高用户体验。</li>
<li>与其他前端技术组合使用，例如结合搜索和过滤功能，对虚拟列表进行优化。<br><a name="QGd0c"></a></li>
</ol>
<h4 id="实现思路"><a href="#实现思路" class="headerlink" title="实现思路"></a>实现思路</h4><p>虚拟化列表的实现，需要考虑以下几个方面：</p>
<ol>
<li>数据源：虚拟化列表需要从数据源中获取数据进行渲染。数据源可以是静态数据、异步请求数据或者其他组件动态传入的数据。</li>
<li>可视区域计算：通过监听滚动条位置或者容器尺寸变化，计算出当前可视区域内的数据节点范围，以确定哪些数据需要渲染到页面上。</li>
<li>渲染优化：因为虚拟化列表只渲染可视区域内的数据，因此需要对渲染过程进行优化，如使用对象池管理列表项、使用懒加载等。</li>
</ol>
<p>具体的实现思路如下：</p>
<ol>
<li>计算每个数据节点的高度或宽度，以便于计算可视窗口内显示的数据量，这一步可以在组件 mounted 阶段进行。</li>
<li>监听可视窗口的滚动事件或容器尺寸变化事件，计算出当前可视区域内需要渲染的数据节点范围。</li>
<li>根据数据源和当前可视区域内的数据节点范围，生成需要渲染的列表项，并将其添加至视图中。</li>
<li>将列表项（包括占位符）缓存到对象池中，以便于复用。</li>
<li>在滚动时，更新占位符的高度或宽度，保证滚动条的长度和列表总长度一致。<br><a name="FvqLB"></a></li>
</ol>
<h3 id="谈谈你对渐进式框架的理解"><a href="#谈谈你对渐进式框架的理解" class="headerlink" title="谈谈你对渐进式框架的理解"></a>谈谈你对渐进式框架的理解</h3><p>渐进式框架是一种前端开发框架，它可以帮助开发者更快速、高效地开发网站或应用程序。渐进式框架的特点是可以根据需求逐渐引入框架的各种功能，使得应用程序可以在不同的阶段中逐步实现功能。这种方式可以减少一开始就引入大量的代码和功能，从而提高应用程序的性能和可维护性。<br />总之，渐进式框架是一种灵活、高效、可维护的前端开发框架，它可以帮助开发者快速构建高性能、可扩展的应用程序。<br><a name="QrGVm"></a></p>
<h3 id="下单功能模块中怎么限制重复提交订单"><a href="#下单功能模块中怎么限制重复提交订单" class="headerlink" title="下单功能模块中怎么限制重复提交订单"></a>下单功能模块中怎么限制重复提交订单</h3><ol>
<li>按钮设置为不可用或者隐藏状态，避免用户重复点击。</li>
<li>后端拦截<ol>
<li>使用主键唯一约束， 需要客户端在请求下单接口的时候，需要生成一个唯一的请求号，服务端拿这个请求号，判断是否重复请求。</li>
<li>使用Redis锁，用户下单时，分配用户一把锁，这样同一用户的多次重复请求，只有一个请求获取到锁，向下执行逻辑，其他请求获取不到锁直接返回。</li>
<li>使用令牌桶，每次操作前，给当前用户一个一次性的令牌，点击提交时带着令牌一起，后端先去校验令牌的有效性<br><a name="Qnb8l"></a></li>
</ol>
</li>
</ol>
<h3 id="高内聚低耦合"><a href="#高内聚低耦合" class="headerlink" title="高内聚低耦合"></a>高内聚低耦合</h3><p>指在编写JavaScript代码时，倡导将代码分解、组合成独立、可复用的函数或模块，使得每个函数或模块的功能单一，耦合度低，内部逻辑紧密结合，对外表现为一个简单的接口。具体地说，高内聚低耦合包含以下几个方面：</p>
<ol>
<li>高内聚：即使模块或对象内部有多个功能，也应该将其分解成单独、可复用的函数或方法，每个函数或方法只负责一种特定的操作或功能，保证单一职责原则。</li>
<li>低耦合：不同模块或对象之间的依赖关系应该尽可能少，每个模块或对象只依赖于必要的、最少的其他模块或对象，使得各个模块或对象能够相对独立，易于维护和测试。</li>
<li>模块化：将代码分解成独立的、可复用的模块，封装隐藏内部实现细节，对外暴露简洁的接口，提高代码的可维护性和可重用性<br><a name="Ul4yy"></a></li>
</ol>
<h3 id="单页面应用和多页面应用的区别，以及使用场景"><a href="#单页面应用和多页面应用的区别，以及使用场景" class="headerlink" title="单页面应用和多页面应用的区别，以及使用场景"></a>单页面应用和多页面应用的区别，以及使用场景</h3><ol>
<li>单页面应用是一种使用 JavaScript 动态载入内容、只在一个页面中加载所有必要的 HTML、CSS 和 JavaScript 的 Web 应用程序。当用户与应用程序交互时，仅更新页面中需要更改的部分而不是重新加载整个页面。单页面应用常使用 AJAX 技术和前端框架（如 Angular、React 和 Vue.js 等）来管理视图和状态。单页面应用的优点是具有更快的响应速度、更好的用户体验、更少的网络流量和更好的可维护性。缺点是搜索引擎优化不佳，并且首次加载时间可能会较长。</li>
<li>多页面应用是指 Web 应用程序拥有多个页面，每个页面都有自己的 URL，每次用户与应用程序交互时都需要重新加载整个页面。多页面应用通常使用传统的服务器端渲染技术，以及后端框架（如 Ruby on Rails、Django、Laravel 等）和模板引擎来管理视图和状态。多页面应用的优点是搜索引擎优化良好、首次加载时间较短，缺点是用户体验较差，流量消耗大。</li>
</ol>
<p>单页面应用适用于需要实现较高用户交互和体验要求的应用程序，如社交网络、在线游戏等。多页面应用适用于需要定制化管理多个页面的企业和商业应用程序，如电子商务网站、业务管理系统等。选择哪种架构需要根据实际情况来综合考虑，权衡各自的优缺点。<br><a name="L2ujE"></a></p>
<h3 id="后端基本的几个数据结构"><a href="#后端基本的几个数据结构" class="headerlink" title="后端基本的几个数据结构"></a>后端基本的几个数据结构</h3><p>数据结构是计算机存储、组织数据的方式。数据结构是指相互之间存在一种或多种特定关系的数据元素的集合。</p>
<ol>
<li>数组</li>
<li>栈</li>
<li>队列</li>
<li>链表</li>
<li>树</li>
<li>散列表</li>
<li>堆</li>
<li>图<br><a name="mo5Mv"></a></li>
</ol>
<h3 id="单点登录"><a href="#单点登录" class="headerlink" title="单点登录"></a>单点登录</h3><p>是一种用户只需在一个认证中心登录一次，就可以访问多个相互信任的应用系统或资源的身份验证机制。这种机制使得用户不需要为每个应用系统单独进行登录验证，减少了用户的重复操作流程和记忆量，提高了用户体验。<br /><strong>基本步骤：</strong></p>
<ol>
<li>统一认证中心<ol>
<li>首先需要建立一个统一的认证中心，所有需要使用SSO的应用系统都向这个中心注册，并通过该中心进行用户身份验证。</li>
</ol>
</li>
<li>认证方式<ol>
<li>为了实现单点登录，通常采用的认证方式是基于Token的验证机制。即用户登录后，认证中心生成Token并返回给应用系统，应用系统将Token存储在客户端的Cookie或者LocalStorage中，以后访问其他应用系统时，认证中心将检查Token的合法性，从而避免了多次登录验证。</li>
</ol>
</li>
<li>跨域存储<ol>
<li>采用 iframe postMessage 机制进行跨域通信，将 Token 存储在其他域的 localStorage 或 sessionStorage 中，并通过跨域通信将 Token 发送给其他应用系统，实现单点登录。<br><a name="ITCHT"></a></li>
</ol>
</li>
</ol>
<h3 id="数据量庞大怎么处理"><a href="#数据量庞大怎么处理" class="headerlink" title="数据量庞大怎么处理"></a>数据量庞大怎么处理</h3><ol>
<li>分页加载：如果后台接口支持分页，可以使用分页技术来减少返回数据的数量。前端可以通过设置每页显示的条目数和当前页数来获取指定页的数据，然后渲染到页面上。</li>
<li>懒加载：对于一些需要滚动触发的列表或大图，可以采用懒加载技术，即当用户滚动到指定位置时再去请求数据和显示图片，从而避免一次性加载所有数据和图片造成的性能压力。</li>
<li>节流与防抖：为了防止用户频繁进行重复操作导致不必要的请求和渲染，可以采用节流（throttle）或者防抖（debounce）技术对前端事件进行控制。节流的目的是定时执行一些事件，防止过度触发；防抖则是在一定时间内未进行操作就执行相应的事件。</li>
<li>本地缓存：对于一些可以缓存的数据，可以使用浏览器提供的本地缓存机制（如 localStorage 和 sessionStorage）或者使用一些开源的缓存库（如 lodash）。通过缓存数据，可以减少后台请求，提高前端性能。</li>
<li>数据筛选和分组：在前端对数据进行筛选和分组可以大大减少不必要的数据传输。如果后台返回的数据量很大，可以先根据一些关键字段或条件进行过滤，只返回必要的数据。对于需要分组的数据，可以在前端进行分组处理，然后按照分组后的结果进行渲染。</li>
<li>数据流式处理：在处理大量数据的时候，可以使用数据流式化技术（如从服务器获取的流或本地生成的流），逐个处理每个数据项，从而减小内存占用和提高前端性能。<br><a name="EX9oJ"></a></li>
</ol>
<h3 id="大数据的计算方案"><a href="#大数据的计算方案" class="headerlink" title="大数据的计算方案"></a>大数据的计算方案</h3><p>使用Web Worker在前端进行多线程计算，提高计算效率。<br><a name="oFKeP"></a></p>
<h4 id="WebWorker是什么，怎么用"><a href="#WebWorker是什么，怎么用" class="headerlink" title="WebWorker是什么，怎么用"></a>WebWorker是什么，怎么用</h4><p>Web Worker是在浏览器中运行的后台线程，可以进行复杂的计算操作而不会阻塞主线程。这意味着在进行大量计算或处理大量数据时，Web Worker可以提高前端应用程序的性能和响应速度。Web Worker还可以与主线程进行通信，以便在处理数据时进行协作和同步。<br />在计算完成后，我们使用postMessage()方法将结果发送回主线程。<br />在主线程中使用onmessage()方法监听来自Web Worker的消息。<br><a name="bjXts"></a></p>
<h3 id="Vue项目实现表格拖拽功能"><a href="#Vue项目实现表格拖拽功能" class="headerlink" title="Vue项目实现表格拖拽功能"></a>Vue项目实现表格拖拽功能</h3><p>安装依赖：首先，在您的Vue项目中安装vue-draggable-resizable依赖库。然后调用里面的API<br />引入依赖：在Vue组件中引入 vue-draggable-resizable 并注册为全局或局部组件。<br><a name="eCWVu"></a></p>
<h3 id="前端对于安全这一块的方案以及做法"><a href="#前端对于安全这一块的方案以及做法" class="headerlink" title="前端对于安全这一块的方案以及做法"></a>前端对于安全这一块的方案以及做法</h3><ol>
<li>输入验证：<ol>
<li>使用正则表达式或验证库对用户输入进行验证，确保输入符合预期的格式和规范。</li>
<li>对于用户输入的敏感数据，如密码、支付信息等，应使用特定的验证规则和加密算法进行处理。</li>
</ol>
</li>
<li>跨站脚本攻击（XSS）防护：<ol>
<li>将用户输入的内容进行转义，确保任何特殊字符都被正确处理。</li>
<li>使用框架或模板引擎提供的转义函数，以防止恶意脚本的注入。</li>
</ol>
</li>
<li>跨站请求伪造（CSRF）防护：<ol>
<li>为每个用户会话生成一个唯一的令牌（CSRF Token），并将其与表单或请求一起发送。</li>
<li>在服务器端验证接收到的令牌是否有效，以防止跨站请求伪造攻击。</li>
</ol>
</li>
<li>密码安全：<ol>
<li>要求用户设置强密码，并提供密码强度提示。</li>
<li>在存储用户密码时，使用适当的哈希函数和盐值进行加密，以保护用户密码的安全。</li>
</ol>
</li>
<li>安全的网络通信：<ol>
<li>使用HTTPS协议来加密通信，以确保数据在传输过程中的安全性。</li>
<li>配置服务器，使用SSL&#x2F;TLS证书来启用HTTPS。</li>
</ol>
</li>
<li>权限管理：<ol>
<li>在前端和后端同时进行权限验证，确保用户只能访问其有权限的页面和执行相应的操作。</li>
<li>使用路由守卫或拦截器对需要授权的路由或请求进行权限验证。</li>
</ol>
</li>
<li>客户端数据保护：<ol>
<li>对于敏感数据，如个人身份信息，可以使用现代加密算法对其进行加密。</li>
<li>实现适当的访问控制策略，确保敏感数据只能在合法的情况下被访问。</li>
</ol>
</li>
<li>安全更新和漏洞修复：<ol>
<li>定期更新项目依赖的库、框架和插件，以获取最新的安全补丁和修复已知漏洞。</li>
<li>监控并关注软件供应商发布的安全通告，并按时进行相应的更新和修复。<br><a name="fWJSb"></a></li>
</ol>
</li>
</ol>
<h3 id="Token加密怎么加密的用的什么技术"><a href="#Token加密怎么加密的用的什么技术" class="headerlink" title="Token加密怎么加密的用的什么技术"></a>Token加密怎么加密的用的什么技术</h3><p>前端 Token 加密一般使用 JWT（JSON Web Token）技术。JWT 由三部分组成，分别是 Header、Payload 和 Signature。</p>
<ol>
<li>Header：包含 Token 类型和加密算法信息。</li>
<li>Payload：包含用户信息和其他元数据，如用户ID、用户名、过期时间等。</li>
<li>Signature：用于验证 Token 是否合法的签名，由 Header、Payload 和密钥生成。</li>
</ol>
<p>前端使用 JWT 进行 Token 加密的流程如下：</p>
<ul>
<li>用户登录时，前端将用户信息和其他元数据通过加密算法生成 Token。</li>
<li>前端将 Token 存储在本地，如 LocalStorage 或 Cookie 中。</li>
<li>用户进行需要验证身份的操作时，前端将 Token 发送到后端进行验证。<br><a name="14bd0850"></a></li>
</ul>
<h3 id="框架和底层你有做过吗？"><a href="#框架和底层你有做过吗？" class="headerlink" title="框架和底层你有做过吗？"></a>框架和底层你有做过吗？</h3><p>常见的前端框架有 Vue、React、Angular 等。这些框架都提供了一套完整的工具链，包括组件化开发、数据绑定、路由、状态管理等功能，使得开发者可以更加专注于业务逻辑的实现，而不必过多关注底层实现细节。<br />底层指的是浏览器提供的原生 API，包括 DOM 操作、事件处理、网络请求等。前端框架通常会封装这些底层 API，提供更加高级和易用的接口，使得开发者可以更加方便地使用这些功能，同时也能够提高应用程序的性能和稳定性。<br><a name="FKRkE"></a></p>
<h3 id="有封装过组件吗？什么类型的？"><a href="#有封装过组件吗？什么类型的？" class="headerlink" title="有封装过组件吗？什么类型的？"></a>有封装过组件吗？什么类型的？</h3><p><a name="ts2mA"></a></p>
<h4 id="表格组件的封装可以从以下几个方面入手："><a href="#表格组件的封装可以从以下几个方面入手：" class="headerlink" title="表格组件的封装可以从以下几个方面入手："></a>表格组件的封装可以从以下几个方面入手：</h4><p>表格数据：表格通常需要展示大量的数据，可以通过 props 属性来接收数据，并通过 v-for 指令来渲染表格行和列。<br />表头封装：表格通常需要展示表头，可以将表头封装成一个组件，并通过 slot 插槽来支持自定义表头内容和样式。<br />分页封装：表格数据可能非常多，需要进行分页展示，可以将分页器封装成一个组件，并通过 slot 插槽来支持自定义分页器样式和文本。<br />排序、筛选封装：表格数据可能需要进行排序和筛选操作，可以将排序和筛选器封装成组件，并通过事件和属性来实现数据排序和筛选。<br><a name="DAojK"></a></p>
<h4 id="表单组件的封装可以从以下几个方面入手："><a href="#表单组件的封装可以从以下几个方面入手：" class="headerlink" title="表单组件的封装可以从以下几个方面入手："></a>表单组件的封装可以从以下几个方面入手：</h4><p>表单布局：表单通常包含多个表单项，可以通过布局组件来实现表单的排版，例如使用栅格布局或者 Flex 布局等。<br />表单项封装：每个表单项通常包含一个标签和一个输入框，可以将标签和输入框封装成一个组件，例如 Input 组件、Select 组件、Checkbox 组件等。<br />表单验证：表单通常需要进行验证，可以在表单项组件中添加验证规则，并通过 v-model 指令来进行数据双向绑定，同时可以在表单组件中添加验证方法，对整个表单进行验证。<br />提交按钮：表单通常包含一个提交按钮，可以将提交按钮封装成一个组件，并通过 slot 插槽来实现自定义按钮文本和样式。<br><a name="ae836497"></a></p>
<h3 id="elementui与想要的效果不一样，怎么解决？"><a href="#elementui与想要的效果不一样，怎么解决？" class="headerlink" title="elementui与想要的效果不一样，怎么解决？"></a><strong>elementui与想要的效果不一样，怎么解决？</strong></h3><p>先检查我们有没有用对这个组件，再看传入的一些数据正不正确，然后可以去自定义一些样式（Element UI 的组件通常有一些 CSS 类名可以用来自定义样式，可以查看文档中的 CSS 类名列表，并编写自定义样式来覆盖默认样式。）<br><a name="ag6g0"></a></p>
<h3 id="文件上传"><a href="#文件上传" class="headerlink" title="文件上传"></a>文件上传</h3><p><a name="zEYvf"></a></p>
<h4 id="断点续传和分片上传"><a href="#断点续传和分片上传" class="headerlink" title="断点续传和分片上传"></a>断点续传和分片上传</h4><p>断点续传和分片上传都是一种上传大文件的优化策略，用于在网络不稳定或文件过大导致上传失败时，提供更好的上传体验。<br /><strong>断点续传</strong>是指当上传大文件时，通过将文件分成多个小部分（块），依次上传每一小部分。在上传某一小部分过程中，如遇到网络故障或其他中断，可以通过记录已上传的数据信息，下次继续从上次上传的断点处重新上传，从而实现文件上传的续传功能。<br /><strong>分片上传</strong>则是将文件划分成若干个大小不等的分片，每个分片独立上传，上传完成后，服务端再将所有分片组合成完整的文件。分片上传相对于断点续传更细粒度，可以实现更快的上传速度和更好的上传体验。<br />总的来说，<strong>断点续传和分片上传都是为了解决大文件上传的问题，提高上传效率和用户体验</strong>。它们的区别在于断点续传是将整个文件切成若干断点进行上传，而分片上传是将文件分成大小不等的多个分片，分别进行上传，在服务端统一合并。它们各有优劣之处，具体应该根据实际项目需求来选择合适的方案。<br><a name="jXEcd"></a></p>
<h3 id="对于用户输入的信息安全性主要从以下几个方面考虑"><a href="#对于用户输入的信息安全性主要从以下几个方面考虑" class="headerlink" title="对于用户输入的信息安全性主要从以下几个方面考虑"></a>对于用户输入的信息安全性主要从以下几个方面考虑</h3><ol>
<li><strong>输入验证：</strong>可以使用 HTML5 表单验证、JavaScript 正则表达式验证、第三方库如 Validator.js 等来进行输入验证。</li>
<li><strong>加密传输：</strong>使用 HTTPS 协议进行加密传输，可以通过配置 Web 服务器、使用 CDN 服务等方式来实现。</li>
<li><strong>防止 XSS 攻击：</strong>可以使用 DOMPurify、sanitize-html 等库对用户输入的 HTML、CSS 和 JavaScript 代码进行过滤和转义，防止恶意脚本注入。<ol>
<li>XSS：攻击者通过注入恶意脚本代码到 Web 页面中，使得用户在访问该页面时执行恶意脚本，从而达到窃取用户信息、篡改页面内容、发起恶意请求等目的</li>
</ol>
</li>
<li><strong>防止 CSRF 攻击：</strong>可以使用 CSRF Token 对用户请求进行验证，可以在 HTTP 头部字段中添加 X-CSRF-Token 或在 Cookie 中添加 SameSite 属性来实现。</li>
<li><strong>防止点击劫持：</strong>可以使用 X-Frame-Options 和 Content-Security-Policy 等 HTTP 头部字段，防止点击劫持攻击。</li>
<li><strong>安全存储：</strong>可以使用加密存储、哈希存储等方式来保证用户输入的敏感信息的安全存储。<br><a name="DehwC"></a></li>
</ol>
<h2 id="浏览器"><a href="#浏览器" class="headerlink" title="浏览器"></a>浏览器</h2><p><a name="VVKY2"></a></p>
<h3 id="HTTP请求码，解释一下意思"><a href="#HTTP请求码，解释一下意思" class="headerlink" title="HTTP请求码，解释一下意思"></a>HTTP请求码，解释一下意思</h3><ol>
<li>200（成功）服务器已成功处理了请求。</li>
<li>202（已接受）服务器已接受请求，但尚未处理</li>
<li>400（错误请求）服务器不理解请求的语法</li>
<li>401（未授权）请求要求身份验证。</li>
<li>403（禁止）服务器拒绝请求。</li>
<li>404（未找到）服务器找不到请求的网页。</li>
<li>405（禁用的方法）禁用请求中指定的方法</li>
<li>413（请求实体过大）服务器无法处理请求，因为请求实体过大，超出服务器的处理能力</li>
<li>500（服务器内部错误）服务器遇到错误，无法完成请求</li>
<li>504  (服务器响应超时)<br><a name="fgG4d"></a></li>
</ol>
<h3 id="浏览器是怎么渲染页面的"><a href="#浏览器是怎么渲染页面的" class="headerlink" title="浏览器是怎么渲染页面的"></a>浏览器是怎么渲染页面的</h3><ol>
<li>解析HTML文档：浏览器将HTML文档解析成DOM树</li>
<li>解析CSS文档：浏览器将CSS文档解析成CSSOM树</li>
<li>构建渲染树：浏览器将DOM树和CSSOM树结合起来，生成渲染树</li>
<li>页面布局：根据渲染树计算每个元素在屏幕上的位置和大小</li>
<li>绘制：将每个元素绘制出来，形成最终的页面<br><a name="FGSxI"></a></li>
</ol>
<h3 id="Keep-alive"><a href="#Keep-alive" class="headerlink" title="Keep alive"></a>Keep alive</h3><p>HTTP Keep-Alive 是一种 HTTP 协议的头部参数，用于控制当前的 TCP 连接是否采用长连接的方式保持连接状态。当客户端与服务器之间需要频繁地进行通信时，启用 Keep-Alive 可以减少建立和断开连接的开销，提高请求响应速度，降低网络延迟。<br />在启用 Keep-Alive 后，客户端发起第一个请求时会与服务器建立一个 TCP 连接，请求处理完毕后连接会被保持在 open 状态，等待下一个请求的到来。当客户端再次发起请求时，可以复用已经建立好的连接，而不必重新建立连接。当确定本次请求已经完成后，可以选择性地关闭这个连接或者保持此连接的状态，等待下一个请求的到来。<br />Keep-Alive 还可以设置超时时间，如果在规定时间内没有新的请求，则连接会被服务器断开，避免长时间处于占用连接的状态，从而导致资源浪费。<br />需要注意的是，虽然 Keep-Alive 可以减少连接建立和断开的开销，但是并不是所有的浏览器和服务器都支持 Keep-Alive。如果使用的浏览器或服务器不支持 Keep-Alive，则会降低请求响应速度，甚至可能造成网络拥堵，所以在使用时需要根据实际情况进行选择。<br><a name="SY3AY"></a></p>
<h3 id="HTTP缓存"><a href="#HTTP缓存" class="headerlink" title="HTTP缓存"></a>HTTP缓存</h3><p>指在客户端和服务器之间进行HTTP通信时，为了提高性能和减少网络流量，将一些常用的资源（如图片、CSS、JavaScript等）缓存在客户端或代理服务器中，以便下次请求时可以直接从缓存中获取，而不必再次从服务器上获取。<br><a name="b547I"></a></p>
<h4 id="强缓存"><a href="#强缓存" class="headerlink" title="强缓存"></a>强缓存</h4><p>浏览器先检查本地缓存中是否存在该资源的缓存信息（Expires 或 Cache-Control），如果缓存未过期，则直接使用本地缓存，不会向服务器发送请求。<br><a name="efBK6"></a></p>
<h4 id="协商缓存"><a href="#协商缓存" class="headerlink" title="协商缓存"></a>协商缓存</h4><p>指客户端向服务器发送请求，服务器根据请求头中的If-Modified-Since和If-None-Match字段来判断资源是否有更新，如果没有更新，则返回304 Not Modified响应，客户端直接从缓存中获取资源。有更新则从服务器获取资源<br />缓存过期或者未命中时，浏览器会向服务器发送请求，服务器会根据缓存标识（ETag 或 Last-Modified）来判断资源是否已经被修改。服务器会返回相应的状态码和新的缓存标识，浏览器根据缓存标识来判断是否需要更新缓存。<br><a name="CJXKA"></a></p>
<h4 id="资源缓存到哪里"><a href="#资源缓存到哪里" class="headerlink" title="资源缓存到哪里"></a>资源缓存到哪里</h4><p>一般会被缓存在浏览器或代理服务器中。</p>
<ol>
<li>在浏览器端，浏览器将请求的资源及其响应信息缓存在本地的磁盘上，通常以文件的方式存储。</li>
<li>缓存的位置和存储方式因浏览器不同而异，但大致可以分为两种<ol>
<li>内存缓存一般用于缓存经常被访问的资源，其生命周期短暂，通常只在该浏览器进程中有效。</li>
<li>硬盘缓存则是持久化地保存缓存的资源，即使浏览器关闭后再次打开也能复用。</li>
</ol>
</li>
<li>对于代理服务器，例如CDN、反向代理等，缓存的位置也多数是在自己的磁盘中，代理服务器在接收到客户端请求后，先判断是否有缓存存在，如果有，则直接返回缓存的结果，否则再转发请求到后端服务器获取新的响应结果，同时将响应结果缓存到代理服务器中供以后的请求使用。<br><a name="DYE9v"></a></li>
</ol>
<h3 id="网址简化"><a href="#网址简化" class="headerlink" title="网址简化"></a>网址简化</h3><p><strong>协议:&#x2F;&#x2F;域名:端口号&#x2F;资源位置?参数&#x3D;值</strong><br><a name="Maqg7"></a></p>
<h3 id="HTTP和HTTPS"><a href="#HTTP和HTTPS" class="headerlink" title="HTTP和HTTPS"></a>HTTP和HTTPS</h3><p>HTTP（超文本传输协议）和HTTPS（安全超文本传输协议）都是应用层协议，用于在Web浏览器和Web服务器之间传输数据。<br /><strong>解释：</strong></p>
<ul>
<li>HTTP是一种不加密的协议，信息在网络上传输的过程中，未经过任何加密处理，存在安全风险，容易被黑客窃取、篡改或中间人攻击。HTTP是基于TCP协议的，每一个HTTP请求都会建立一个新的TCP连接，这种方式显然会造成网络带宽的浪费。</li>
<li>为了保证数据的安全性，在HTTP协议上，开发出了HTTPS协议。HTTPS通过SSL&#x2F;TLS对数据进行加密和身份认证，可以有效防止数据被窃取和篡改。</li>
<li>HTTPS协议在传输过程中使用了SSL&#x2F;TLS协议进行数据加密和身份认证，所以可以保证数据的完整性、机密性和可靠性。</li>
</ul>
<p><strong>区别：</strong>主要区别在于是否涉及到数据传输加密和身份验证，HTTP不涉及任何加密处理，而HTTPS则通过SSL&#x2F;TLS进行加密和身份验证。<br><a name="AcqES"></a></p>
<h3 id="SSL-TLS是什么"><a href="#SSL-TLS是什么" class="headerlink" title="SSL&#x2F;TLS是什么"></a>SSL&#x2F;TLS是什么</h3><p>SSL（安全套接字层）和TLS（传输层安全性）是用来保证网络通信安全的一种协议。SSL是较老的加密协议，而TLS是其后继者。<br />SSL&#x2F;TLS协议通过在通信双方之间建立安全通道，在数据传输过程中采用加密、身份验证和完整性校验等措施，来防止第三方截获、篡改或伪造数据。<br />总之，SSL&#x2F;TLS协议能够有效地保护网络通信安全，是互联网上进行加密通信的基础。<br><a name="Ng0bj"></a></p>
<h3 id="HTTP协议"><a href="#HTTP协议" class="headerlink" title="HTTP协议"></a>HTTP协议</h3><p>它是一种客户端-服务端协议，通常基于TCP协议进行通信。<br />HTTP协议通过一个请求-响应的方式来进行数据传输，客户端向服务端发送一个HTTP请求，服务端根据请求返回一个HTTP响应。请求和响应都有固定的格式和结构，包括一些头信息和一个可选的消息体。HTTP协议的请求方法包括GET、POST、PUT、DELETE等，而响应状态码则表示服务器对请求的处理结果。<br />HTTP协议的优点是简单、灵活、易于扩展，支持多种数据格式和编码方式，可以通过代理服务器、缓存和Cookie等技术提高网络性能和用户体验。不过，HTTP协议也存在一些弱点，例如安全性较差和无法处理复杂交互等问题，这些问题在个别场景下已经被HTTPS和WebSocket等协议解决。<br><a name="uh2VS"></a></p>
<h3 id="TCP-IP基本工作原理"><a href="#TCP-IP基本工作原理" class="headerlink" title="TCP&#x2F;IP基本工作原理"></a>TCP&#x2F;IP基本工作原理</h3><p>TCP&#x2F;IP协议栈工作的基本原理如下：</p>
<ol>
<li>TCP和UDP协议负责数据的传输：TCP协议提供面向连接的可靠传输服务，通过三次握手建立连接，并为每个连接维护一个发送和接收缓冲区；UDP协议提供无连接的不可靠传输服务，适用于实时交互和多播等场景。</li>
<li>IP协议负责数据的路由和转发：IP协议定义了数据在网络中的传输方式，负责将数据包从源主机发送到目的主机。</li>
<li>ARP协议负责地址解析：ARP协议提供了将IP地址映射到硬件地址的解析机制，使得数据能够被正确地发送到目的主机。</li>
<li>DNS协议负责主机名解析：DNS协议提供了将主机名解析为IP地址的服务，避免了用户需要记住复杂的IP地址的问题。</li>
<li>HTTPS协议在TCP&#x2F;IP协议栈之上提供了安全化的通讯服务。</li>
</ol>
<p>TCP&#x2F;IP协议还采用了分层的设计方式，由四层构成：网络接口层、网络层、传输层、应用层。每一层都有自己独特的功能和特点，协议之间通过接口进行交互。<br />总之，TCP&#x2F;IP协议栈是实现互联网通信的一组关键技术，它的工作原理包括数据传输、路由和转发、地址解析、主机名解析等多个方面，通过分层的设计有效提高了协议的可靠性和可扩展性。<br><a name="HyNnv"></a></p>
<h3 id="输入网址之后发生了什么"><a href="#输入网址之后发生了什么" class="headerlink" title="输入网址之后发生了什么"></a>输入网址之后发生了什么</h3><ol>
<li>DNS解析。浏览器首先会根据输入的网址解析出对应的IP地址。如果该IP地址已经存在于浏览器缓存中，则直接使用该IP地址。否则，浏览器会向本地DNS服务器发起请求，本地DNS服务器会向根DNS服务器、顶级DNS服务器以及权威DNS服务器依次发送请求，直到找到对应的IP地址。最终，该IP地址会被存储在本地DNS服务器中，并返回给浏览器端。</li>
<li>发起TCP连接。浏览器会向服务器发起TCP连接请求。这个过程通常是通过三次握手完成的，即客户端向服务器发送SYN（同步）包，服务器收到后回复SYN+ACK包，客户端再回复ACK包。这样，TCP连接就建立了。</li>
<li>发起HTTP请求。TCP连接建立之后，浏览器就可以向服务器发起HTTP请求了。HTTP请求包括请求头、请求方法、请求URL等信息。</li>
<li>服务器响应。服务器接收到HTTP请求后，会做出响应。响应的内容包括状态码、响应头、响应正文等信息。</li>
<li>解析渲染页面。浏览器收到服务器响应后，会对其进行解析和渲染。浏览器会根据响应头中的Content-Type字段来确定文档类型，并进行相应的处理，包括构建DOM树、渲染页面、执行JavaScript脚本等。</li>
<li>断开TCP连接。当浏览器完成对网页的渲染之后，会断开与服务器的TCP连接。这个过程通常是通过四次挥手完成的，即浏览器向服务器发送FIN包，服务器回复ACK包，服务器向浏览器发送FIN+ACK包，浏览器回复ACK包。这样，TCP连接就正式关闭了。<br><a name="kcnCa"></a></li>
</ol>
<h3 id="TCP三次握手"><a href="#TCP三次握手" class="headerlink" title="TCP三次握手"></a>TCP三次握手</h3><p>三次握手由以下三个步骤组成：</p>
<ol>
<li>建立连接时，客户端发送syn包刀服务器，等待服务器确认。</li>
<li>服务器收到syn包。必须确认客户的SYN，同时自己也发送一个SYN包到客户端</li>
<li>客户端收到服务器的SYN+ACK包，向服务器发送确认包ACK，发送完毕，客户端和服务器进入（TCP连接成功）状态，完成三次握手。</li>
</ol>
<p>三次握手的优点是能够保证双方都具有可靠性，而且相对简单，缺点是会增加网络延迟和消耗一些带宽。但TCP协议的可靠性和稳定性十分重要，因此三次握手始终是建立TCP连接时必须要执行的过程。<br><a name="VL6H4"></a></p>
<h3 id="TCP四次挥手"><a href="#TCP四次挥手" class="headerlink" title="TCP四次挥手"></a>TCP四次挥手</h3><ol>
<li>客户端发送一个FIN报文，表示客户端已经没有数据要发送了，并请求关闭连接。</li>
<li>服务器收到FIN报文后，向客户端发送ACK报文，表示已经收到了客户端的关闭请求。此时，服务器端进入CLOSE_WAIT（关闭等待）状态，等待最后的数据传送完成。</li>
<li>当服务器的数据都传递完后，服务器会向客户端发送一个FIN报文，表示服务器已经没有数据要发送了。</li>
<li>客户端收到FIN报文后，向服务器发送ACK报文作为响应，表示已经收到了服务器的关闭请求，此时客户端进入TIME_WAIT（时间等待）状态。客户端会保持等待状态一段时间，以确保服务器收到了自己的ACK报文。在等待期间，如果收到服务器重发的FIN报文，客户端会重新发送ACK报文，并重新进入等待状态。如果没有再次收到FIN报文，客户端会关闭TCP连接。<br><a name="JvBie"></a></li>
</ol>
<h3 id="页面数据实时刷新"><a href="#页面数据实时刷新" class="headerlink" title="页面数据实时刷新"></a>页面数据实时刷新</h3><p><strong>轮询：</strong>利用 setInterval 或者 setTimeout 函数定时向服务端发送请求，获取最新的数据。但是轮询的实时性和效率都比较低，容易造成浪费和重复请求的问题。<br /><strong>长轮询：</strong>在轮询的基础上进行优化，即客户端向服务端发起一个长时间的 HTTP 请求，并保持连接处于打开状态。当服务端有了新的数据时，就会马上返回给客户端。这种方式虽然比轮询更加实时、高效，但仍需消耗较多资源。<br /><strong>WebSockets：</strong>WebSocket 是一种全双工通信协议，可以在客户端和服务端之间建立一个持久化的连接，实现实时数据传输和交互。WebSocket 采用轻量级的信息交换格式，且在传输过程中只需要较少的数据解析，因此相比其他两种方法，实时性更高、效率更好。<br><a name="FwaBQ"></a></p>
<h3 id="WebSocket"><a href="#WebSocket" class="headerlink" title="WebSocket"></a>WebSocket</h3><p>WebSocket是一种在单个TCP连接上进行全双工通信的协议，它可以在客户端和服务器之间建立一个持久化的连接，实现实时通讯和数据传输。WebSocket协议可以在HTTP协议上进行扩展，通过HTTP握手建立连接，然后通过WebSocket协议进行数据传输。<br />与HTTP请求-响应模式不同，WebSocket协议采用异步通讯方式，客户端和服务器可以随时向对方发送数据，而不需要等待对方的响应。这种实时通讯方式可以大大提高应用程序的响应速度和用户体验，适用于在线游戏、实时聊天、股票行情等需要实时数据传输的场景。<br />在前端开发中，可以使用JavaScript的WebSocket API来实现WebSocket通讯。WebSocket API提供了一些方法和事件，可以用来建立连接、发送数据、接收数据等操作。在Vue项目中，可以使用WebSocket API来实现实时通讯和消息推送功能，提高系统的效率和用户体验。<br><a name="rwkqJ"></a></p>
<h4 id="怎么用"><a href="#怎么用" class="headerlink" title="怎么用"></a>怎么用</h4><ol>
<li>建立连接</li>
</ol>
<pre><code class="vue">const socket = new WebSocket(&#39;ws://localhost:3000&#39;);
</code></pre>
<ol start="2">
<li>事件处理：WebSocket 对象会触发一些事件，如打开、关闭、错误和接收消息等，可以通过绑定事件监听器的方式来处理这些事件</li>
</ol>
<pre><code class="vue">socket.addEventListener(&#39;open&#39;, event =&gt; &#123;  
  console.log(&#39;Socket opened&#39;);
&#125;);
socket.addEventListener(&#39;close&#39;, event =&gt; &#123;
  console.log(&#39;Socket closed&#39;);
&#125;);
socket.addEventListener(&#39;error&#39;, error =&gt; &#123;
  console.error(&#39;Socket error:&#39;, error);
&#125;);
socket.addEventListener(&#39;message&#39;, event =&gt; &#123;
  console.log(&#39;Received message:&#39;, event.data);
&#125;)
</code></pre>
<ol start="3">
<li>发送消息：在通过 WebSocket 建立连接后，可以通过 WebSocket 对象的 send() 方法向服务器发送消息</li>
</ol>
<pre><code class="vue">socket.send(&#39;Hello, Server!&#39;);
</code></pre>
<ol start="4">
<li>关闭连接：在需要关闭 WebSocket 连接时，可以通过 close() 方法完成</li>
</ol>
<pre><code class="vue">socket.close();
</code></pre>
<p><strong>同时，需要注意以下几个事项：</strong><br />在使用 WebSocket 时需要保证服务器支持该协议，否则将无法建立连接。<br />WebSocket 协议默认使用的是 ws 协议（非加密），如果需要加密可以使用 wss 协议。<br />在传输大量数据时，需要考虑数据压缩和分段传输等问题，以提高传输效率和数据安全性。<br />对于一些较老的浏览器版本可能不支持 WebSocket ，需要进行兼容性处理。可以使用一些 polyfill 库或采用其他实现方式等来解决问题。<br><a name="oUl4s"></a></p>
<h3 id="浏览器请求方式"><a href="#浏览器请求方式" class="headerlink" title="浏览器请求方式"></a>浏览器请求方式</h3><ol>
<li>GET<ol>
<li>GET 方法是用于向指定资源请求数据的一种请求方法，通常用于获取服务器上的数据。使用 GET 请求时，参数会附加在 URL 后面，以问号 ? 开始，不同参数之间以 &amp; 连接。由于 GET 请求的参数会显示在地址栏中，所以使用 GET 请求时应避免传递机密信息。</li>
</ol>
</li>
<li>POST<ol>
<li>POST 方法是用于提交被处理的数据，通常用于向服务器发送数据，并且不希望数据出现在 URL 中。使用 POST 请求时，参数会放在请求体中进行传输，相对于 GET 请求更加安全，一般用于提交表单数据、上传文件等操作。</li>
</ol>
</li>
<li>PUT<ol>
<li>PUT 方法是用于替换指定资源或者更新指定资源中部分内容的请求方法。通常用于更新资源或者新建资源。使用 PUT 请求时，需要传递完整的资源内容，即使只修改了部分内容也需要将整个资源传递给服务器端。</li>
</ol>
</li>
<li>DELETE<ol>
<li>DELETE 方法是用于删除指定资源的请求方法。通常用于删除资源，但是需要注意删除后无法恢复，需要谨慎使用。</li>
</ol>
</li>
<li>OPTION<ol>
<li>OPTION 方法是用于查询服务器支持哪些方法的请求方法。通常在跨域请求前进行预检检查时使用。</li>
</ol>
</li>
<li>HEAD<ol>
<li>HEAD 方法与 GET 方法类似，但是服务器端仅返回响应头信息，不返回响应体内容。一般用于获取资源的元信息。<br><a name="K7jwN"></a></li>
</ol>
</li>
</ol>
<h4 id="GET和POST的区别"><a href="#GET和POST的区别" class="headerlink" title="GET和POST的区别"></a>GET和POST的区别</h4><ol>
<li>参数传递<ol>
<li>GET请求将参数信息放在URL中，而POST请求将参数信息放在请求体中。</li>
</ol>
</li>
<li>安全性<ol>
<li>GET请求的参数会明文出现在URL上，不够安全；而POST请求的参数在请求体中，相对更加安全。</li>
</ol>
</li>
<li>使用场景<ol>
<li>GET请求适用于查询操作，因为它的请求具备幂等性（多次执行返回的结果相同），而且GET请求通常比POST请求更加高效。</li>
<li>POST请求适用于对资源进行修改或增加操作，例如提交表单，上传文件等。因为POST请求会修改服务器端的资源状态，所以它不能重复提交，如果重复提交可能会产生不可预知的后果。<br><a name="pcZ2I"></a></li>
</ol>
</li>
</ol>
<h4 id="GET和POST有没有缓存"><a href="#GET和POST有没有缓存" class="headerlink" title="GET和POST有没有缓存"></a>GET和POST有没有缓存</h4><ol>
<li>对于GET请求，浏览器会默认缓存响应结果。当下次请求相同URL时，如果满足一定条件，浏览器会直接从缓存中读取响应数据，而不再向服务器发送请求</li>
<li>对于POST请求，由于它通常用于向服务器提交数据，因此浏览器不会缓存POST请求的响应结果。每次POST请求都会向服务器发送请求，并且服务器必须重新生成响应结果。</li>
</ol>
<p>需要<strong>注意</strong>的是，虽然POST请求的响应结果不会被浏览器缓存，但是POST请求本身可能会被浏览器缓存。比如，当用户点击浏览器的“后退”按钮时，可能会看到之前提交的POST表单数据。为避免这种情况，可以在表单中添加随机值等标识符来防止缓存。<br><a name="AT2DQ"></a></p>
<h3 id="跨域"><a href="#跨域" class="headerlink" title="跨域"></a>跨域</h3><p><a name="HoZag"></a></p>
<h4 id="什么是跨域"><a href="#什么是跨域" class="headerlink" title="什么是跨域"></a>什么是跨域</h4><p>是指在浏览器中，当前 Web 应用程序所请求的资源（如图片、脚本、样式表等）位于另外一个域名下。<br><a name="AdQ2y"></a></p>
<h4 id="为什么会引起跨域"><a href="#为什么会引起跨域" class="headerlink" title="为什么会引起跨域"></a>为什么会引起跨域</h4><p>是由于Web浏览器实现了同源策略（Same-Origin Policy），同源策略要求页面内所有资源请求必须来源于相同的协议（protocol）、 域名（host）和端口号（port），否则就会被浏览器拒绝。<br><a name="sZ14e"></a></p>
<h4 id="怎么解决跨域"><a href="#怎么解决跨域" class="headerlink" title="怎么解决跨域"></a>怎么解决跨域</h4><ol>
<li>**JSONP: **JSONP是一种使用script标签进行跨域数据传输的技术，它允许页面从另一个域名下获取数据，但是仅限于使用GET请求。JSONP通过在URL中添加回调函数名的方式来传递数据，因此需要有服务端支持，返回一个函数调用，并将要传递的数据作为参数传递给这个函数。<ol>
<li>而 JSONP 通过动态创建 script 标签，指向一个跨域的 URL，然后服务器返回一个 JSON 数据串，并包装在回调函数中，以便客户端在获得数据后自动执行该回调函数。这样就可以绕过浏览器的同源策略，实现跨域访问并获取数据。</li>
</ol>
</li>
<li><strong>跨域资源共享（CORS）：</strong>CORS是一种通过添加HTTP头部信息来使得浏览器与服务器进行沟通、跨域传输数据的方式。</li>
<li><strong>反向代理：</strong>反向代理是一种通过将客户端请求转发到服务器端的方式来解决跨域问题的方法。在同一个域名下，客户端将请求发送给代理服务器，代理服务器再将请求发送到目标服务器，并将目标服务器响应的内容返回给客户端，从而实现跨域数据传输。<br><a name="CjnFQ"></a></li>
</ol>
<h3 id="服务端渲染跟客户端渲染有什么区别，优缺点是什么"><a href="#服务端渲染跟客户端渲染有什么区别，优缺点是什么" class="headerlink" title="服务端渲染跟客户端渲染有什么区别，优缺点是什么"></a>服务端渲染跟客户端渲染有什么区别，优缺点是什么</h3><ol>
<li>渲染位置不同：服务端渲染是在服务器端将模板转换为 HTML 网页后发送给客户端，而客户端渲染是在浏览器端通过 JavaScript 引擎生成 HTML 标签并渲染。</li>
<li>响应速度不同：服务端渲染在客户端请求时直接返回已经准备好的 HTML 内容，因此响应速度较快；而客户端渲染需要先下载网页的基础代码，再通过 AJAX 或 WebSocket 进行异步请求获取数据，最后再渲染界面，因此响应速度较慢。</li>
<li>SEO 友好程度不同：由于搜索引擎爬虫无法执行 JavaScript 代码，因此客户端渲染的页面对于搜索引擎来说是不友好的，而服务端渲染则可以在服务器上生成 HTML 页面，让搜索引擎可以更好地抓取和索引页面内容，从而提升 SEO 的效果。</li>
<li>开发难度不同：客户端渲染需要大量的 JavaScript 和其他前端技术，开发更加复杂，追求用户体验时需要花费更多的精力和时间，而服务端渲染则相对简单一些，可以利用现有的后端技术进行开发。<br><a name="QApmo"></a></li>
</ol>
<h3 id="垃圾回收机制"><a href="#垃圾回收机制" class="headerlink" title="垃圾回收机制"></a>垃圾回收机制</h3><p>是指浏览器通过一定的算法和规则自动检测和清除不再被引用的内存空间，以便回收资源，提高浏览器 运行效率。</p>
<ol>
<li>标记-清除算法：该算法通过标记“可达性分析”来判断哪些对象仍然存活在内存中。当垃圾回收器判断某个对象不可达时，即不再被任何其他对象引用，就会将其标记为垃圾对象，并将其占用的内存空间批量回收。</li>
<li>引用计数算法：该算法通过计数来判断对象的引用次数。每当对象被新创建或被引用时，计数器加1；当对象被释放或引用失效时，计数器减1。当计数器为0时，即表示该对象不再被引用，可以进行清理。<br><a name="ayRh4"></a></li>
</ol>
<h3 id="浏览器如何渲染页面"><a href="#浏览器如何渲染页面" class="headerlink" title="浏览器如何渲染页面"></a>浏览器如何渲染页面</h3><ul>
<li>发送http请求：浏览器向服务器发送http请求，请求服务器提供指定的网页资源。[1]</li>
<li>接收html文件：服务器接收到请求后，将网页的html文件作为响应返回给浏览器。浏览器对html文件进行解析，构建DOM树。[1][2]</li>
<li>加载CSS：浏览器会根据不同的方式加载CSS文件，将其解析成CSS规则，并形成CSSOM（CSS Object Model），并与DOM树结合构建render tree。[2]</li>
<li>布局和绘制：根据构建好的render tree计算节点的几何属性，确定每个节点在页面中的位置和大小，并对节点进行绘制，最终呈现出完整的页面。<br><a name="kjM8R"></a></li>
</ul>
<h3 id="localStorage、sessionStorage和Cookies的区别"><a href="#localStorage、sessionStorage和Cookies的区别" class="headerlink" title="localStorage、sessionStorage和Cookies的区别"></a>localStorage、sessionStorage和Cookies的区别</h3><ol>
<li>数据存储方式：localStorage和sessionStorage都是基于HTML5标准的Web Storage机制，数据存储在浏览器中；而Cookies则是使用HTTP协议传输的，在服务器端设置，在客户端存储。</li>
<li>数据存储大小：Cookies一般只能存储4KB左右的数据，而localStorage和sessionStorage可以存储更大的数据，一般可以达到5MB左右。</li>
<li>存储时间：localStorage中保存的数据长期存在，除非用户手动删除浏览器缓存；而sessionStorage中的数据仅在当前会话下有效，当用户关闭浏览器窗口时，存储在sessionStorage中的数据会被清除。</li>
<li>数据访问权限：Cookies中保存的数据可以被同一域名下的所有页面访问和共享；而localStorage和sessionStorage中保存的数据只能被同一域名下同一协议（http或https）的页面访问和共享。<br><a name="XWVTm"></a></li>
</ol>
<h3 id="JS跟CSS会阻塞线程吗？为什么？"><a href="#JS跟CSS会阻塞线程吗？为什么？" class="headerlink" title="JS跟CSS会阻塞线程吗？为什么？"></a>JS跟CSS会阻塞线程吗？为什么？</h3><p>对于CSS资源，如果采用外部引入的方式，会使用浏览器的缓存机制，在第一次加载后，后续的页面访问就可以直接从缓存中读取，不会重复下载，因此对主线程的影响很小。但如果CSS资源是通过内嵌样式或者style标签的方式嵌入在HTML文件中，则会和HTML的解析一起进行，如果CSS样式比较复杂或者文件较大，可能会导致页面的阻塞。<br />对于JS资源，如果采用了defer或async的方式，会异步加载JS文件，不会阻塞HTML的解析和渲染，不过大多数情况下，都是采用普通的script标签进行加载，这个时候JS脚本的下载和执行会阻塞页面的渲染，也就是说，只有当前JS文件下载和执行完成后，才能继续进行下一步HTML的解析和渲染。<br><a name="kVbOQ"></a></p>
<h2 id="Vue"><a href="#Vue" class="headerlink" title="Vue"></a>Vue</h2><p><a name="K9L70"></a></p>
<h3 id="Vue打包发布流程"><a href="#Vue打包发布流程" class="headerlink" title="Vue打包发布流程"></a>Vue打包发布流程</h3><ol>
<li>执行命令：npm run build</li>
<li>命令执行成功之后，项目目录下会生成一个dist文件夹 （里面包含：static文件夹和index.html文件）</li>
<li>把dist文件夹下的所有文件复制到之前配置的nginx默认主页目录下（也可以是自己设置的网站目录）<br><a name="oQ1bb"></a></li>
</ol>
<h3 id="Vue打包体积过大导致首屏加载缓慢"><a href="#Vue打包体积过大导致首屏加载缓慢" class="headerlink" title="Vue打包体积过大导致首屏加载缓慢"></a>Vue打包体积过大导致首屏加载缓慢</h3><ol>
<li>按需引入组件：在使用Vue时，应该尽量避免一次性将所有组件都引入，而是根据实际需要来进行按需引入，减小打包体积。可以使用Vue的异步组件、动态import()语法等方式实现。</li>
<li>拆分公共代码：将一些公共的代码拆分出来成为单独的chunk，可以减少重复加载的代码量，从而提高网页的加载速度。</li>
<li>异步加载：对于耗时较长的资源（如大型的JS脚本、CSS文件、图片等），可以使用异步加载技术，将资源按需加载，避免首次加载时出现卡顿。</li>
<li>优化图片加载：合理使用图片压缩、雪碧图、图片懒加载等技术，可以减小图片的大小，提高网页的加载速度。</li>
<li>优化路由：合理使用路由懒加载、预加载等技术，可以减少首屏加载的资源量，提高网页的响应速度。<br><a name="f81uR"></a></li>
</ol>
<h3 id="Vue项目上的性能优化"><a href="#Vue项目上的性能优化" class="headerlink" title="Vue项目上的性能优化"></a>Vue项目上的性能优化</h3><ol>
<li>使用v-if和v-show：在需要显示&#x2F;隐藏元素时，使用v-if比v-show更好，因为v-if可以在不需要显示元素时直接销毁它，而v-show则只是改变其CSS属性。</li>
<li>合理使用计算属性和watch：避免在模板中直接使用复杂的表达式或函数，而应该使用计算属性来优化计算逻辑。如果需要监听某个变量的变化，可以使用watch来代替手动监测数据变化。</li>
<li>合理使用v-for：在使用v-for渲染列表时，要确保能够设置唯一的key值，并且尽量减少在模板中使用复杂的表达式。</li>
<li>异步加载组件：对于一些比较大的组件，可以使用异步组件来进行按需加载，减少首屏渲染的时间。</li>
<li>将静态资源打包到CDN：将一些静态资源（如图片、字体等）打包到CDN上，可以减轻服务器的负担，提高网页的加载速度。</li>
<li>开启Gzip压缩：开启Gzip压缩可以减小文件的大小，提高网页的加载速度。</li>
<li>使用keep-alive缓存组件：对于一些页面需要频繁切换的组件，可以使用keep-alive来对组件进行缓存，以减少频繁的渲染操作。</li>
<li>避免频繁操作DOM：频繁操作DOM会导致网页的重绘和回流，从而影响性能。因此，在使用Vue时应该尽量减少频繁操作DOM的情况，可以使用v-bind或v-html来代替直接操作DOM。</li>
<li>优化网络请求：合理使用缓存、减小请求数据大小、选择合适的请求方式等都可以有效地提高网络请求的性能。<br><a name="rMReP"></a></li>
</ol>
<h3 id="Vue的生命周期及理解"><a href="#Vue的生命周期及理解" class="headerlink" title="Vue的生命周期及理解"></a>Vue的生命周期及理解</h3><p>Vue.js 的生命周期是指 Vue 实例从创建、运行到销毁的整个过程中，Vue 在处理一个组件实例时所自动调用的钩子函数的集合。这些钩子函数构成了 Vue 组件的生命周期。<br />Vue.js 的生命周期钩子函数都有一个相应的执行时机，可以分为如下四个阶段：创建阶段、挂载阶段、更新阶段、销毁阶段。</p>
<ol>
<li>创建阶段：包括 beforeCreate、created两个生命周期钩子函数，在 beforeCreate 钩子函数中，Vue 实例的初始化工作尚未开始，data、props、methods和computed 等数据都不可用；而在 created 钩子函数中，Vue 实例已经完成了数据的观测（即 data 属性中的属性值被转化为 getter&#x2F;setter）和事件的初始化。</li>
<li>挂载阶段：包括 beforeMount、mounted两个生命周期钩子函数，beforeMount 钩子函数在模板编译生成的 HTML 代码未挂载至页面前被调用，此时 Vue 实例只是一堆未挂载的 VNode（虚拟节点）；而 mounted 钩子函数在模板编译生成的 HTML 代码已将 Vue 实例挂载至页面后被调用，此时 Vue 实例已经变成了真正的 DOM 对象，并且可以访问到 DOM。</li>
<li>更新阶段：包括 beforeUpdate、updated 两个生命周期钩子函数，在数据更新导致视图更新时触发。beforeUpdate 钩子函数在 Vue 实例的数据更新之前被调用，可以用于在数据更新后执行一些异步操作；而 updated 钩子函数在 Vue 实例的数据更新之后被调用，此时组件已完成更新过程。</li>
<li>销毁阶段：包括 beforeDestroy、destroyed两个生命周期钩子函数，beforeDestroy 钩子函数在组件销毁之前被调用，可以用于清除定时器、解绑自定义事件等操作；而在 destroyed 钩子函数中，组件实例已经完全销毁并解除所有绑定的事件监听器和子组件实例。<br><a name="RpDNB"></a></li>
</ol>
<h3 id="声明周期的作用是什么"><a href="#声明周期的作用是什么" class="headerlink" title="声明周期的作用是什么"></a>声明周期的作用是什么</h3><p>在vue生命周期的不同阶段通过对应的钩子函数来实现组件数据管理和DOM渲染两大重要功能<br><a name="ui74W"></a></p>
<h3 id="父子组件的生命周期执行顺序"><a href="#父子组件的生命周期执行顺序" class="headerlink" title="父子组件的生命周期执行顺序"></a>父子组件的生命周期执行顺序</h3><ol>
<li>父组件 beforeCreate 钩子函数被调用，父组件实例创建之前。</li>
<li>父组件 created 钩子函数被调用，父组件实例创建完成之后。</li>
<li>子组件 beforeCreate 钩子函数被调用，子组件实例创建之前。</li>
<li>子组件 created 钩子函数被调用，子组件实例创建完成之后。</li>
<li>子组件 beforeMount 钩子函数被调用，子组件挂载之前。</li>
<li>子组件 mounted 钩子函数被调用，子组件挂载之后。</li>
<li>父组件 beforeMount 钩子函数被调用，父组件挂载之前。</li>
<li>父组件 mounted 钩子函数被调用，父组件挂载之后。</li>
<li>父组件 beforeUpdate 钩子函数被调用，父组件更新之前。</li>
<li>子组件 beforeUpdate 钩子函数被调用，子组件更新之前。</li>
<li>子组件 updated 钩子函数被调用，子组件更新之后。</li>
<li>父组件 updated 钩子函数被调用，父组件更新之后。</li>
<li>父组件 beforeDestroy 钩子函数被调用，父组件销毁之前。</li>
<li>子组件 beforeDestroy 钩子函数被调用，子组件销毁之前。</li>
<li>子组件 destroyed 钩子函数被调用，子组件销毁之后。</li>
<li>父组件 destroyed 钩子函数被调用，父组件销毁之后。<br><a name="bNTWr"></a></li>
</ol>
<h3 id="双向数据绑定原理"><a href="#双向数据绑定原理" class="headerlink" title="双向数据绑定原理"></a>双向数据绑定原理</h3><p>vue.js 是采用数据劫持结合发布者-订阅者模式的方式，通过Object.defineProperty()来劫持各个属性的setter，getter，在数据变动时发布消息给订阅者，触发相应的监听回调。<br><a name="I4nIR"></a></p>
<h3 id="虚拟DOM的作用"><a href="#虚拟DOM的作用" class="headerlink" title="虚拟DOM的作用"></a>虚拟DOM的作用</h3><p>Vue虚拟DOM的作用是在页面渲染时，通过对比新旧虚拟DOM树的差异，最小化地更新页面的DOM元素，从而提高页面渲染的效率和性能。具体来说，Vue会将模板转换成虚拟DOM树，然后通过对比新旧虚拟DOM树的差异，找出需要更新的部分，最后只更新这些部分对应的DOM元素，而不是重新渲染整个页面。这种方式可以减少DOM操作的次数，提高页面渲染的效率，同时也可以避免一些常见的性能问题，比如频繁的重绘和回流。<br><a name="QBUYx"></a></p>
<h3 id="diff算法"><a href="#diff算法" class="headerlink" title="diff算法"></a>diff算法</h3><p>指Vue在更新视图时，通过比较新旧虚拟DOM树的差异，最小化地更新DOM，提高性能的一种算法。</p>
<ol>
<li>先同级比较，在比较子节点</li>
<li>先判断一方有子节点一方没子节点的情况</li>
<li>比较都有子节点的情况</li>
<li>递归比较子节点<br><a name="WGD09"></a></li>
</ol>
<h3 id="真实DOM和虚拟DOM的区别"><a href="#真实DOM和虚拟DOM的区别" class="headerlink" title="真实DOM和虚拟DOM的区别"></a>真实DOM和虚拟DOM的区别</h3><p>真实 DOM 是浏览器提供的一种将 HTML 页面转化为具有树形结构的对象模型的方式，通过 JavaScript 脚本来对其进行操作。在使用真实 DOM 进行大量的动态操作时，其效率会降低，这是因为每次进行 DOM 操作都需要重新计算布局，进行页面重绘，从而导致性能下降。<br />虚拟 DOM 是一种将数据和视图分离的设计思想，可以看做是真实 DOM 的轻量级抽象。当数据发生变化时，我们不再直接操作真实 DOM，而是先将其转化为虚拟 DOM 对象，之后对其进行修改，最后再将修改后的虚拟 DOM 与之前的版本进行比较，计算出最小化的 DOM 操作量，最终只更新需要修改的部分，以此来提高渲染性能。<br />虚拟 DOM 在性能上有如下优势：</p>
<ol>
<li>减少了直接操作真实 DOM，从而避免了反复计算布局 和页面重绘带来的性能开销；</li>
<li>可以对多个操作进行批处理，以减少更新次数，提高渲染性能；</li>
<li>支持跨平台运行，可用于服务端渲染等场景。</li>
</ol>
<p>但虚拟 DOM 也存在缺点：</p>
<ol>
<li>需要引入额外的计算来构建虚拟 DOM 与比对差异等操作，会占用一定的性能资源；</li>
<li>在大型应用中，虚拟 DOM 对象可能会变得非常庞大，导致内存开销较大。<br><a name="XEJBD"></a></li>
</ol>
<h3 id="render函数"><a href="#render函数" class="headerlink" title="render函数"></a>render函数</h3><p>render函数是一个JavaScript函数，它接收一个createElement方法作为参数，用于创建各种类型的Vue节点，例如标签节点、文本节点、组件节点等。通过render函数，我们可以用template或者纯JS对象来描述我们的页面结构。<br /><strong>好处：</strong>它可以帮助我们避免使用模板时出现的一些限制，例如无法进行复杂的计算或者条件判断等。此外，使用render函数还可以提高页面的性能，因为它省去了模板解析的过程，直接生成VNode节点，从而减少渲染的时间和开销。<br><a name="a5j1F"></a></p>
<h3 id="v-if和v-show的区别"><a href="#v-if和v-show的区别" class="headerlink" title="v-if和v-show的区别"></a>v-if和v-show的区别</h3><p>回答：</p>
<ol>
<li>共同点：在 vue 中 v-show 与 v-if 的作用效果是相同的(不含v-else)，都能控制元素在页面是否显示 </li>
<li>不同点：<ol>
<li>v-show隐藏则是为该元素添加css–display:none，dom元素依旧还在。v-if显示隐藏是将dom元素整个添加或删除</li>
<li>v-if切换有一个局部编译&#x2F;卸载的过程，切换过程中合适地销毁和重建内部的事件监听和子组件；v-show只是简单的基于css切换</li>
<li>v-if是真正的条件渲染，它会确保在切换过程中条件块内的事件监听器和子组件适当地被销毁和重建。只有渲染条件为假时，并不做操作，直到为真才渲染，v-show 由false变为true的时候不会触发组件的生命周期。</li>
<li>v-if由false变为true的时候，触发组件的beforeCreate、create、beforeMount、mounted钩子，由true变为false的时候触发组件的beforeDestory、destoryed方法</li>
<li>性能消耗：v-if有更高的切换消耗；v-show有更高的初始渲染消耗；</li>
</ol>
</li>
<li>使用场景<ol>
<li>v-if 相比 v-show 开销更大的（直接操作dom节点增加与删除）</li>
<li>如果需要非常频繁地切换，则使用 v-show 较好，如果在运行时条件很少改变，则使用 v-if 较好<br><a name="QourE"></a></li>
</ol>
</li>
</ol>
<h3 id="v-for跟v-if为什么不能一起用"><a href="#v-for跟v-if为什么不能一起用" class="headerlink" title="v-for跟v-if为什么不能一起用"></a>v-for跟v-if为什么不能一起用</h3><p>当 Vue 处理指令时，v-for 比 v-if 具有更高的优先级，这意味着 v-if 将分别重复运行于每个 v-for 循环中，造成性能方面的浪费。（每次渲染都会先循环再进行条件判断）<br><a name="grliU"></a></p>
<h3 id="Vue-js为什么采用异步渲染"><a href="#Vue-js为什么采用异步渲染" class="headerlink" title="Vue.js为什么采用异步渲染"></a>Vue.js为什么采用异步渲染</h3><p>主要原因是为了提高页面的渲染性能和用户体验。异步渲染的核心思想就是将一次大量的DOM更新操作拆分成多个小的DOM更新操作，通过分批次渲染来降低主线程的压力，从而提高页面的响应速度和流畅度。<br><a name="lNI4N"></a></p>
<h3 id="Vue实现强制刷新"><a href="#Vue实现强制刷新" class="headerlink" title="Vue实现强制刷新"></a>Vue实现强制刷新</h3><ol>
<li>使用 key 属性：通过在需要强制刷新的组件上设置唯一的 key 值，可以触发 Vue 强制重新渲染该组件。当 key 值发生变化时，Vue 会销毁旧组件并创建新组件，从而实现强制刷新。</li>
<li>使用 $forceUpdate 方法：每个 Vue 组件实例都有一个 $forceUpdate 方法，调用该方法会强制组件重新渲染，即使没有进行响应式更新。<br><a name="k0I7M"></a></li>
</ol>
<h3 id="v-for中的key的作用"><a href="#v-for中的key的作用" class="headerlink" title="v-for中的key的作用"></a>v-for中的key的作用</h3><p>在Vue进行更新时，会先对新旧节点进行比较，找到需要更新的节点，并对这些节点进行更新操作。如果没有设置key值，那么Vue就只能按照节点的位置进行比较，这样就可能会出现错误的更新结果。而有了唯一的key值后，Vue就可以根据key值来识别出每个节点的身份，从而实现精确的更新操作。<br />需要注意的是，key值必须是唯一且稳定的，通常应该使用每个节点所对应的数据的唯一标识符作为key值。如果使用不稳定的key值，就可能会导致节点身份的混乱，从而引发错误的更新结果。<br><a name="qk7kX"></a></p>
<h4 id="使用index作为Key值"><a href="#使用index作为Key值" class="headerlink" title="使用index作为Key值"></a>使用index作为Key值</h4><ol>
<li>如果数组数据会发生变化，例如插入、删除、排序等操作，那么使用索引作为 key 可能会导致错误的渲染结果。因为某个元素在数组中的索引发生变化之后，它对应的 key 值也发生了变化，可能会导致 Vue 难以追踪节点的正确位置，从而出现渲染错误。</li>
<li>如果存在相同的内容，基于 index 作为 key 会导致它们被视为同一个节点，可能会引起渲染问题。<br><a name="u1gnW"></a></li>
</ol>
<h3 id="自定义指令"><a href="#自定义指令" class="headerlink" title="自定义指令"></a>自定义指令</h3><p>在Vue中，自定义指令可以通过指令函数或指令对象来定义，其中指令函数接收两个参数：el和binding，而指令对象可以包含多个选项。</p>
<pre><code class="vue">Vue.directive(&#39;my-directive&#39;, function(el, binding) &#123;
  // 指令执行时的钩子函数
&#125;)
</code></pre>
<p><a name="thjqj"></a></p>
<h3 id="computed和watch的区别"><a href="#computed和watch的区别" class="headerlink" title="computed和watch的区别"></a>computed和watch的区别</h3><p>computed属性和watch的本质都是一个watcher实例，它们都可以用来监听数据变化并执行相应的回调函数。<br /><strong>computed属性：</strong>是一个计算属性，它的值是通过依赖其他的属性计算出来的，它的值会被缓存(缓存到Vue实例中)，只有当依赖的属性发生变化时才会重新计算。<br /><strong>watch属性：</strong>则是用来监听特定数据的变化，从而进行一些具体的业务逻辑操作。watch属性可以监听 data，props，computed内的数据等，只要被监听的数据发生变化，就会触发相应的回调函数。watch属性不会对监听的数据进行缓存，每次数据变化都会触发回调函数。<br /><strong>使用场景：</strong></p>
<ol>
<li>computed属性适用于那种需要经过计算才能得到最终结果的数据</li>
<li>watch属性则适用于那些需要在数据发生变化时立刻进行响应的场景<br><a name="l6h5b"></a></li>
</ol>
<h4 id="watcher实例"><a href="#watcher实例" class="headerlink" title="watcher实例"></a>watcher实例</h4><p>是Vue中用于观察数据变化并进行相应操作的一个核心对象。它主要负责在Vue实例初始化时创建、管理并执行具体的观察者回调函数，当依赖的数据发生变化时，Watcher会通知相关的组件或指令进行重新渲染。<br /><strong>Watcher实例有三种类型：</strong></p>
<ol>
<li>渲染Watcher：在Vue实例初始化时创建，在渲染过程中依赖的所有数据变化时都会执行回调函数，并将得到的结果渲染成真正的DOM。</li>
<li>计算属性Watcher：当定义计算属性时，会自动创建一个计算属性Watcher，其会对依赖的属性进行求值，并缓存结果。当依赖的属性发生变化时，会重新求值并更新缓存。</li>
<li>监听器Watcher：通过$watch和watch选项设置的回调函数创建的Watcher，用于监视数据变化并做出响应操作。<br><a name="pRCzC"></a></li>
</ol>
<h3 id="组件通信"><a href="#组件通信" class="headerlink" title="组件通信"></a>组件通信</h3><p><strong>Vuex</strong><br />props传递数据：适用场景：父组件传递数据给子组件<br />$emit 触发自定义事件：适用场景：子组件传递数据给父组件<br />ref：父组件在使用子组件的时候设置ref，父组件通过设置子组件ref来获取数据</p>
<pre><code class="vue">  父组件：
  &lt;Childer ref=&#39;foo&#39; /&gt;
</code></pre>
<p>EventBus：使用场景：兄弟组件传值</p>
<ol>
<li>创建一个中央时间总线EventBus</li>
<li>兄弟组件通过$emit触发自定义事件，$emit第二个参数为传递的数值</li>
<li>另一个兄弟组件通过$on监听自定义事件</li>
</ol>
<p>provide 与 inject：</p>
<ol>
<li>在祖先组件定义provide属性，返回传递的值</li>
<li>在后代组件通过inject接收组件传递过来的值<br><a name="peu1z"></a></li>
</ol>
<h3 id="scoped样式隔离的原理"><a href="#scoped样式隔离的原理" class="headerlink" title="scoped样式隔离的原理"></a>scoped样式隔离的原理</h3><p>在编译时，Vue 会自动为每个拥有 scoped 属性的样式添加唯一的属性选择器，该选择器包含了组件的唯一 id。<br><a name="tKR9t"></a></p>
<h3 id="Vue3侦听器"><a href="#Vue3侦听器" class="headerlink" title="Vue3侦听器"></a>Vue3侦听器</h3><p>watchEffect 会自动地收集组件中使用到的响应式数据，并根据其变化情况自动执行对应的回调函数；watchPostEffect 则会在组件渲染结束之后再执行回调函数，可以用于处理一些与渲染结果相关的后续逻辑。<br><a name="P3vBv"></a></p>
<h4 id="执行时机"><a href="#执行时机" class="headerlink" title="执行时机"></a>执行时机</h4><ol>
<li>watchEffect 函数会在其依赖的响应式数据发生变化时，对应地被立即执行。具体来说，Vue 3 会在 watchEffect 函数内部自动地追踪使用到的响应式数据，并在这些数据变化时调用 watchEffect 函数。</li>
<li>watchPostEffect 函数会在组件的渲染结束后再执行对应的回调函数。具体来说，watchPostEffect 函数会在当前组件及其子组件的所有渲染完毕后执行。因此，watchPostEffect 函数适合于实现一些与渲染结果相关的后续操作，例如对 DOM 元素进行操作、发送网络请求等等。<br><a name="sJz4k"></a></li>
</ol>
<h3 id="Proxy双向数据绑定的原理"><a href="#Proxy双向数据绑定的原理" class="headerlink" title="Proxy双向数据绑定的原理"></a>Proxy双向数据绑定的原理</h3><ol>
<li>创建一个目标对象（target object），即需要进行数据绑定的对象。</li>
<li>创建一个Proxy对象，使用它来代理目标对象，并监听目标对象的变化，同时将变化同步到其他依赖该对象的视图或模型上。</li>
<li>在Proxy对象的set方法中，捕获对目标对象的赋值操作，并通知相关依赖更新数据。<br><a name="mkqcV"></a></li>
</ol>
<h3 id="Vue2双向绑定的缺陷"><a href="#Vue2双向绑定的缺陷" class="headerlink" title="Vue2双向绑定的缺陷"></a>Vue2双向绑定的缺陷</h3><ol>
<li>性能问题：Object.defineProperty() 要为每个对象的每个属性添加getter和setter，当数据量较大时，会造成性能问题。</li>
<li>无法监听数组下标变化：由于Object.defineProperty()的局限性，Vue无法通过它监听到数组下标的变化。Vue为了解决这个问题，对数组进行了Hack，通过重写数组的方法来实现监听，从而引入了一系列诡异调试难度的行为。</li>
<li>对象深层嵌套监听复杂：当对象层级过深时，需要逐层遍历对象添加getter&#x2F;setter，实现起来比较繁琐，也会进一步影响性能。<br><a name="Yn5RS"></a></li>
</ol>
<h3 id="Vue3和Vue2的区别"><a href="#Vue3和Vue2的区别" class="headerlink" title="Vue3和Vue2的区别"></a>Vue3和Vue2的区别</h3><p><strong>V2和V3双向数据绑定原理发生了改变</strong><br />vue2的双向数据绑定是利用了es5 的一个API Object.definepropert() 对数据进行劫持 结合发布订阅模式来实现的。vue3中使用了es6的proxyAPI对数据进行处理。<br><a name="qq6pH"></a></p>
<h4 id="改进了v-model"><a href="#改进了v-model" class="headerlink" title="改进了v-model"></a>改进了v-model</h4><p>在Vue2中，v-model指令只能用于表单元素（如input、select和textarea等）的双向数据绑定。而在Vue3中，v-model指令支持自定义组件的双向数据绑定，这意味着我们可以使用v-model指令来实现自定义组件之间的双向数据传输。<br><a name="kFdl9"></a></p>
<h4 id="使用v-model绑定自定义组件时自定义组件中应该做什么"><a href="#使用v-model绑定自定义组件时自定义组件中应该做什么" class="headerlink" title="使用v-model绑定自定义组件时自定义组件中应该做什么"></a>使用v-model绑定自定义组件时自定义组件中应该做什么</h4><ol>
<li>在子组件中通过 props 属性接收 modelValue 和 update:modelValue 属性。</li>
<li>子组件内部通过 $emit(‘update:modelValue’,value) 触发父组件绑定的事件来更新值。<br><a name="dDNa3"></a></li>
</ol>
<h4 id="V2和V3双向数据绑定原理的区别"><a href="#V2和V3双向数据绑定原理的区别" class="headerlink" title="V2和V3双向数据绑定原理的区别"></a>V2和V3双向数据绑定原理的区别</h4><p>在 Vue.js 2.x 中，双向绑定的实现是通过 Object.defineProperty() 来劫持对象、数组中属性的 set 和 get 方法，然后在数据变化时通知依赖更新。这种方式需要监听每个属性的变化，对于数组还需要特别处理。<br />而在 Vue.js 3.x 中，采用了 Proxy 对象来劫持数据，Proxy 相比 Object.defineProperty() 可以直接代理整个对象，不需要监听每个属性，也可以很直观地拦截多种操作，从而更好地实现数据劫持和响应式<br />因此，可以看出 Vue.js 3.x 的双向数据绑定原理相比 Vue.js 2.x 更加高效和精简。同时，Vue.js 3.x 中还引入了 Composition API，让代码可以更加组合化和可复用，方便开发者进行业务逻辑抽离和重构。<br><a name="TU8hC"></a></p>
<h4 id="Composition-API"><a href="#Composition-API" class="headerlink" title="Composition API"></a>Composition API</h4><p>Composition API 是 Vue.js 3.x 中的一组 API，它允许我们使用导入函数而不是声明选项来编写 Vue 组件。它是一个统称，包括以下 API：</p>
<ul>
<li>响应式 API：例如 ref() 和 reactive()，允许我们直接创建响应式状态、计算状态和观察器；</li>
<li>生命周期钩子：例如 onMounted()、onUpdated() 和 onUnmounted()，用于在组件的生命周期中添加逻辑；</li>
<li>其他实用程序函数：例如 watch() 和 provide() 等等。</li>
</ul>
<p>与传统的 Options API 相比，Composition API 可以更好地组织代码、提高代码可读性、可维护性和可测试性<br><a name="mFArt"></a></p>
<h4 id="Options-API"><a href="#Options-API" class="headerlink" title="Options API"></a>Options API</h4><p>Vue.js 的 Options API 是 Vue 2.x 版本中的一种组件定义方式，它是一组对象选项（Options），包括 data、props、computed、watch 等等，用于定义一个 Vue 组件<br><a name="wan0K"></a></p>
<h3 id="nextTick原理"><a href="#nextTick原理" class="headerlink" title="$nextTick原理"></a>$nextTick原理</h3><p>Vue实现响应式并不是数据发生变化之后 DOM 立即变化，而是按一定的策略进行 DOM 的更新。$nextTick 是在下次 DOM 更新循环结束之后执行延迟回调，在修改数据之后使用 $nextTick，则可以在回调中获取更新后的 DOM。<br><a name="AidAN"></a></p>
<h3 id="Ref"><a href="#Ref" class="headerlink" title="Ref"></a>Ref</h3><p>ref是Vue中常用的一个指令，用于在模板或组件中给元素或组件注册引用信息，以便在JavaScript代码中对它们进行访问。相当于是为HTML元素添加一个标记，然后通过这个标记来获取到对应的元素。</p>
<ol>
<li>使用ref绑定DOM之后使用this.$refs.(ref绑定的名)获取DOM<br><a name="LfBsm"></a></li>
</ol>
<h3 id="Vuex"><a href="#Vuex" class="headerlink" title="Vuex"></a>Vuex</h3><p><a name="OLwMC"></a></p>
<h4 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h4><p><strong>优点</strong></p>
<ul>
<li>能够在vuex中,集中管理共享的数据,易于开发和后期维护；</li>
<li>Vuex 的状态存储是响应式的，当 Vue 组件从 store中读取状态的时候，若 store 中的状态发生变化，能够触发响应式的渲染页面更新 (localStorage就不会)，那么相应的组件也会相应地得到高效更新。</li>
<li>js 原生的数据对象写法, 比起 localStorage 不需要做转换, 使用方便</li>
<li>限定了一种可预测的方式改变数据, 避免大项目中, 数据不小心的污染</li>
</ul>
<p><strong>缺点</strong></p>
<ul>
<li>刷新浏览器，vuex中的state会重新变为初始状态 ；</li>
<li>解决方案-插件 vuex-persistedstate<br><a name="nkY2X"></a></li>
</ul>
<h4 id="为什么Mutation-是同步的而Action是异步的"><a href="#为什么Mutation-是同步的而Action是异步的" class="headerlink" title="为什么Mutation 是同步的而Action是异步的"></a>为什么Mutation 是同步的而Action是异步的</h4><p>Mutation 负责修改状态并确保状态的可预测性和可追溯性，因此必须是同步的。<br />Action 负责提交 Mutation 并处理与状态相关的异步操作，因此一般都是异步的。<br />如果 Action 是同步的，那么这些异步操作将会阻塞整个程序的执行，导致用户界面卡顿，或者导致应用程序崩溃。<br><a name="diXlV"></a></p>
<h4 id="刷新页面之后VueX所管理的数据会丢失怎么解决"><a href="#刷新页面之后VueX所管理的数据会丢失怎么解决" class="headerlink" title="刷新页面之后VueX所管理的数据会丢失怎么解决"></a>刷新页面之后VueX所管理的数据会丢失怎么解决</h4><p>因为vuex里的数据是保存在运行内存中的，当页面刷新时，页面会重新加载vue实例，vuex里面的数据就会被清空。</p>
<ol>
<li>将 Vuex 数据持久化到本地存储中，在刷新页面时从本地存储中读取数据并重新加载到 Vuex 中。</li>
<li>在组件中使用 created 钩子函数来初始化 Vuex 数据，并在 beforeunload 事件中将数据保存到本地存储中。<br><a name="HVfP3"></a></li>
</ol>
<h4 id="Vuex和本地存储的区别"><a href="#Vuex和本地存储的区别" class="headerlink" title="Vuex和本地存储的区别"></a>Vuex和本地存储的区别</h4><ol>
<li>最重要的区别：vuex存储在内存，localstorage则以文件的方式存储在本地</li>
<li>应用场景：vuex用于组件之间的传值，localstorage则主要用于不同页面之间的传值，</li>
<li>永久性：当刷新页面时vuex存储的值会丢失，localstorage不会。<br><a name="LzOU7"></a></li>
</ol>
<h4 id="Vuex定义的全局数据跟状态跟我在main-js中定义的全局数据和状态有什么区别"><a href="#Vuex定义的全局数据跟状态跟我在main-js中定义的全局数据和状态有什么区别" class="headerlink" title="Vuex定义的全局数据跟状态跟我在main.js中定义的全局数据和状态有什么区别"></a>Vuex定义的全局数据跟状态跟我在main.js中定义的全局数据和状态有什么区别</h4><ol>
<li><strong>数据管理范围不同。</strong>Vuex将应用程序中的所有组件所共有的数据都存储在Vuex的store中，方便在多个组件中共享和修改数据。而在main.js中定义的全局数据和状态是只能在根实例中使用的，各个组件不能直接访问。</li>
<li><strong>数据获取方式不同。</strong>在Vuex中通过this.$store.state.xxx获取state中的数据；在main.js中定义的全局数据和状态，我们可以通过Vue.prototype.xxx &#x3D; ‘yyy’ 设置一个原型属性，然后在组件中使用this.xxx获取值。</li>
<li><strong>数据的修改方式不同。</strong>在Vuex中使用commit()方法来调用mutations中的方法，修改state中的数据，从而更新应用程序中的数据。而在main.js中定义的全局数据和状态，我们可以直接在Vue.prototype.xxx &#x3D; ‘yyy’处改变属性的值，但这样会导致状态散落在应用程序的各个地方，不易维护和管理。<br><a name="ca1aZ"></a></li>
</ol>
<h3 id="路由"><a href="#路由" class="headerlink" title="路由"></a>路由</h3><p><a name="w3W5W"></a></p>
<h4 id="vue-router是什么？route是什么？有什么组件？"><a href="#vue-router是什么？route是什么？有什么组件？" class="headerlink" title="vue-router是什么？route是什么？有什么组件？"></a>vue-router是什么？route是什么？有什么组件？</h4><p><strong>router：</strong>全局路由的实例，是router构造方法的实例<br /><strong>route：</strong>表示当前的路由信息，包含了当前 URL 解析得到的信息。包含当前的路径，参数，query对象等。<br /><strong>组件：</strong></p>
<ol>
<li>router-link：组件支持用户在具有路由功能的应用中 (点击) 导航。 通过to 属性指定目标地址，默认渲染成带有正确链接的<a> 标签，在不重新加载页面的情况下更改 URL，处理 URL 的生成以及编码</li>
<li>router-view：将显示与 url 对应的组件。你可以把它放在任何地方，以适应你的布局。<br><a name="fwKvA"></a></li>
</ol>
<h4 id="路由的原理"><a href="#路由的原理" class="headerlink" title="路由的原理"></a>路由的原理</h4><p>监听的是onhashchange事件，根据哈希值变化来实现页面切换。如果哈希值发生变化了，在事件函数展示对应的界面。更新视图但不重新请求页面<br><a name="jRSdK"></a></p>
<h4 id="动态路由"><a href="#动态路由" class="headerlink" title="动态路由"></a>动态路由</h4><p>在合适的时候调用对应的 **router.addRoute()**（添加路由函数）以及 **router.removeRoute()**（ 删除路由函数）<br><a name="FO17s"></a></p>
<h4 id="权限管理"><a href="#权限管理" class="headerlink" title="权限管理"></a>权限管理</h4><p>权限管理就是让不同的用户只能访问自己权限内的资源，有以下几种：</p>
<ol>
<li>路由权限：用户登录后只能看到自己权限内的导航菜单，且只能访问自己权限内的路由地址</li>
<li>视图权限：用户只能看到自己权限内的内容和按钮</li>
<li>请求权限：越权请求将其拦截</li>
</ol>
<p><strong>怎么实现权限管理</strong><br><a name="LVziX"></a></p>
<h4 id="路由守卫有哪些，干什么用的"><a href="#路由守卫有哪些，干什么用的" class="headerlink" title="路由守卫有哪些，干什么用的"></a>路由守卫有哪些，干什么用的</h4><ol>
<li>全局前置守卫<ol>
<li>router.beforeEach 在进入路由前执行的钩子函数，它会接收三个参数：to(要进入的路由对象)、from(当前导航正要离开的路由对象)和 next(必须调用该函数才能进入下一个钩子)</li>
</ol>
</li>
<li>全局后置守卫<ol>
<li>router.afterEach 在进入路由后执行的钩子函数，它不接收 next 函数，也不能改变导航。主要用于改变页面的标题名</li>
</ol>
</li>
<li>路由独享守卫<ol>
<li>beforeEnter 在路由配置中定义的钩子函数，它会在路由被激活之前调用。它和全局前置守卫的参数一样，但是只对该路由生效</li>
</ol>
</li>
<li>组件守卫<ol>
<li>beforeRouteEnter：在路由进入时异步加载组件前调用。</li>
<li>beforeRouteUpdate：在当前路由改变，但是该组件被复用时调用(例如，从 &#x2F;users&#x2F;1 导航到 &#x2F;users&#x2F;2 时)。</li>
<li>beforeRouteLeave：在离开当前路由时调用。<br><a name="CoIPi"></a></li>
</ol>
</li>
</ol>
<h4 id="路由缓存"><a href="#路由缓存" class="headerlink" title="路由缓存"></a>路由缓存</h4><p>keep-alive是vue中的内置组件，能在组件切换过程中将状态保留在内存中，防止重复渲染DOM<br />keep-alive可以设置以下props属性：</p>
<ol>
<li>include - 字符串或正则表达式。只有名称匹配的组件会被缓存</li>
<li>exclude - 字符串或正则表达式。任何名称匹配的组件都不会被缓存</li>
<li>max - 数字。最多可以缓存多少组件实例</li>
</ol>
<p><strong>注意：</strong></p>
<ul>
<li>使用 <keep-alive> 标签时，被缓存的组件需要有唯一的标识符，可以通过 key 属性来指定。这样在切换同一个路由时，Vue Router 才能正确地匹配到之前缓存的组件。</li>
<li>缓存的组件会占用一定的内存资源，因此不适用于所有组件。对于一些动态绑定数据的页面，可能需要手动清除缓存或使用其他方式来处理数据的更新。</li>
<li>如果需要针对特定的路由配置启用或禁用缓存，可以使用 meta 字段来进行配置，如示例中的 $route.meta.keepAlive。<br><a name="kRNP8"></a></li>
</ul>
<h5 id="路由缓存的原理"><a href="#路由缓存的原理" class="headerlink" title="路由缓存的原理"></a>路由缓存的原理</h5><ol>
<li>首次加载：当路由切换到包含 <keep-alive> 的组件时，会将该组件的实例缓存起来。</li>
<li>缓存管理：在缓存阶段，Vue Router 会将缓存的组件从 DOM 中移除，但不会销毁这些组件的实例。</li>
<li>组件保留：被缓存的组件实例会被存储在内存中，并保持其状态、数据和 DOM 结构。</li>
<li>再次访问：当再次切换到同一个被缓存的路由时，Vue Router 会将之前缓存的组件实例重新添加到 DOM 中，这样可以避免重新创建组件实例和重新渲染 DOM，提高了性能。</li>
<li>生命周期钩子：被缓存的组件不会触发 created 和 mounted 等生命周期钩子函数，因为它们的实例并未被销毁和重新创建，而是保持之前的状态。但是，activated 和 deactivated 生命周期钩子函数会在组件被缓存和离开缓存时触发，可以利用它们来处理进入和离开缓存时的逻辑。<br><a name="zAAt8"></a></li>
</ol>
<h4 id="hash和history的区别"><a href="#hash和history的区别" class="headerlink" title="hash和history的区别"></a>hash和history的区别</h4><ol>
<li>hash模式：在 URL 中 # 后面的部分称为 hash，hash 的变化不会触发页面的刷新，而是通过监听浏览器的 hashchange 事件来监听 hash 值的变化，从而实现前端路由。hash 路由相对简单，支持所有浏览器，并且可以直接用于静态文件的部署，缺点是 hash 值会显示在 URL 中，不够美观。</li>
<li>history模式：利用 HTML5 新增的 history.pushState() 和 history.replaceState() 方法来实现前端路由。在 history 模式下，URL 中不含有 # 号，路由变化时通过监听 popstate 事件来响应路由变化。相对于 hash 模式，history 模式的 URL 更加美观，但是需要服务器支持，否则在用户手动刷新或直接访问路由的时候会出现 404 错误。<ol>
<li>为什么会出现404：因为当用户手动刷新或直接访问该页面对应的路由路径时，浏览器会向服务器发送一次请求，而此时页面并没有被加载过，且该 URL 对应的真实资源并不存在，服务器就会返回 HTTP 404 错误码，表示客户端所请求的资源不存在。</li>
</ol>
</li>
<li>push是追加历史记录，replace是<strong>替换当前记录</strong>，路由跳转时候默认是push<br><a name="M0b8C"></a></li>
</ol>
<h4 id="前端根据角色权限管理进行动态路由一般是在哪一部分进行处理的"><a href="#前端根据角色权限管理进行动态路由一般是在哪一部分进行处理的" class="headerlink" title="前端根据角色权限管理进行动态路由一般是在哪一部分进行处理的"></a>前端根据角色权限管理进行动态路由一般是在哪一部分进行处理的</h4><p>前端路由管理通常使用Vue Router实现。与静态路由相比，动态路由可以根据当前用户的角色和权限来动态生成路由，从而实现页面访问的灵活控制。<br />具体来说，前端在获取到当前用户的角色和权限信息之后，可以使用Vue Router提供的API（例如router.addRoute()）动态注册路由，并通过路由匹配来实现页面的跳转。<br />另外，为了避免前端路由被绕过，还需要在服务端进行相应的权限验证。例如，在请求API接口时，服务端可以根据当前用户的角色和权限信息来进行请求的合法性验证，从而保证前端路由访问的安全性。<br><a name="KZzkA"></a></p>
<h4 id="路由传参的两种方式的区别"><a href="#路由传参的两种方式的区别" class="headerlink" title="路由传参的两种方式的区别"></a>路由传参的两种方式的区别</h4><ol>
<li>Query传参方式：通过URL后面拼接参数的方式传递参数。<ol>
<li>优点是可以传递任何类型的数据，而且不会改变原有路由路径</li>
<li>缺点是不太安全，因为参数会暴露在URL中，容易被篡改</li>
</ol>
</li>
<li>Params传参方式：通过在路由配置中设置参数的方法传递参数。<ol>
<li>优点是可以使用路由的动态参数，更加灵活，而且参数不会暴露在URL中，相对更安全</li>
<li>缺点是只能传递字符串类型的数据</li>
</ol>
</li>
</ol>
<p>总体来说，如果需要传递少量基本数据类型的数据，可以使用 query 参数；如果需要传递复杂的数据结构或者数据量较大，推荐使用 params 参数。<br><a name="fjl1Q"></a></p>
<h3 id="你对组件的理解"><a href="#你对组件的理解" class="headerlink" title="你对组件的理解"></a>你对组件的理解</h3><p>组件是可复用的Vue实例，它拥有独一无二的组件名称，它可以扩展HTML元素，以组件名称的方式作为自定义的HTML标签。<br><a name="gsK4G"></a></p>
<h3 id="封装Vue组件的时候应该考虑哪些方面"><a href="#封装Vue组件的时候应该考虑哪些方面" class="headerlink" title="封装Vue组件的时候应该考虑哪些方面"></a>封装Vue组件的时候应该考虑哪些方面</h3><ol>
<li>功能性：组件应该实现特定的功能，为用户提供便捷的操作。</li>
<li>可复用性：组件的设计应该具有可复用性，方便在其他项目中使用。</li>
<li>可扩展性：组件应该易于扩展，在需求变化时能够方便地进行修改。</li>
<li>可维护性：组件应该易于维护，代码结构清晰，变量、函数、方法等命名规范，注释详尽。</li>
<li>兼容性：组件应该考虑多浏览器和移动端设备的兼容性。</li>
<li>性能优化：组件应该通过合理的设计和实现来达到最佳的性能。</li>
<li>用户体验：组件应该具有良好的用户交互和视觉效果，以提升用户体验。<br><a name="hnxSW"></a></li>
</ol>
<h3 id="父组件调用子组件-子调父"><a href="#父组件调用子组件-子调父" class="headerlink" title="父组件调用子组件,子调父"></a>父组件调用子组件,子调父</h3><p>父组件可以通过 ref 属性获取子组件的实例，并调用子组件中的方法。<br />子组件可以通过 $emit 方法触发父组件中的事件，并将数据传递给父组件。<br />在使用npm安装包时，常用的三个选项是-S、-D和-g，它们的具体含义如下：<br><a name="j9twh"></a></p>
<h3 id="npm-install-安装包时，常用的-S-、-D-、-g-有什么区别？"><a href="#npm-install-安装包时，常用的-S-、-D-、-g-有什么区别？" class="headerlink" title="npm install 安装包时，常用的-S 、-D 、-g 有什么区别？"></a>npm install 安装包时，常用的-S 、-D 、-g 有什么区别？</h3><ol>
<li>-S（–save）：</li>
</ol>
<p>该选项表示将安装的包保存到项目的dependencies中，它会将当前包作为生产环境的依赖来安装和保存。这些依赖包将被部署到生产环境，例如部署到服务器等。<br />命令行示例：npm install package-name -S</p>
<ol start="2">
<li>-D（–save-dev）：</li>
</ol>
<p>该选项表示将安装的包保存到项目的devDependencies中，它会将当前包作为开发环境的依赖来安装和保存。这些依赖包通常用于开发、测试和构建等环境，并不会被部署到生产环境。<br />命令行示例：npm install package-name -D</p>
<ol start="3">
<li>-g（–global）：</li>
</ol>
<p>该选项表示将安装的包保存到全局中，它会将当前包安装到全局环境中，而不是当前项目中。这些包可以被多个项目共享，并且可以直接在命令行中使用，通常用于安装全局的工具或命令行程序。</p>
<p>命令行示例：npm install package-name -g<br><a name="iWPRA"></a></p>
<h3 id="Axios"><a href="#Axios" class="headerlink" title="Axios"></a>Axios</h3><p><a name="Ske9P"></a></p>
<h4 id="拦截器中可以做什么操作"><a href="#拦截器中可以做什么操作" class="headerlink" title="拦截器中可以做什么操作"></a>拦截器中可以做什么操作</h4><ol>
<li><strong>添加公共请求头</strong>：在每次请求时，可以在拦截器中添加一些常用的请求头信息，避免在每个请求中都手动添加。</li>
<li><strong>请求参数处理</strong>：可以在请求拦截器中对请求参数进行处理，例如添加token、加密、序列化等操作。</li>
<li><strong>请求错误处理</strong>：可以在请求拦截器中拦截请求出错的情况，例如网络异常、请求超时等，然后进行相应的处理。</li>
<li><strong>响应数据处理</strong>：可以在响应拦截器中处理响应结果，例如对返回数据进行格式化或加工操作、统一处理错误码等。</li>
<li><strong>统一处理错误码</strong>：可以对不同的请求返回的错误码进行统一处理，例如根据错误码跳转到不同的错误页面或弹窗提示错误信息等<br><a name="bzXie"></a></li>
</ol>
<h4 id="Ajax和Axios的区别"><a href="#Ajax和Axios的区别" class="headerlink" title="Ajax和Axios的区别"></a>Ajax和Axios的区别</h4><ul>
<li>语法和方式：Ajax 原生是通过 XMLHttpRequest 对象发送请求，而 Axios 则是基于 Promise 的方式实现，直接调用 get、post 等方法即可。</li>
<li>功能和特点：Axios 支持更加丰富的功能，比如自动转换 JSON 数据、客户端和服务端都可以使用、可以设置请求拦截器和响应拦截器等。而 Ajax 则是使用原生 XMLHttpRequest 对象进行请求，功能上略逊于 Axios。</li>
<li>代码风格和易用性：Axios 的代码风格比较简洁、易读，其请求方式和参数配置也比 Ajax 更加灵活，使用起来更加便捷。<br><a name="JaIeZ"></a></li>
</ul>
<h3 id="Pinia"><a href="#Pinia" class="headerlink" title="Pinia"></a>Pinia</h3><p>Pinia作为Vue的新一代的状态管理器，Store (如 Pinia) 是一个保存状态和业务逻辑的实体，它并不与你的组件树绑定。换句话说，它承载着全局状态。它有点像一个永远存在的组件，每个组件都可以读取和写入它。它有三个概念，state、getter 和 action，我们可以假设这些概念相当于组件中的 data、 computed 和 methods<br><a name="BcXjZ"></a></p>
<h4 id="为什么要使用pinia"><a href="#为什么要使用pinia" class="headerlink" title="为什么要使用pinia"></a>为什么要使用pinia</h4><p><strong>优点：</strong></p>
<ul>
<li>Vue2和Vue3都支持，这让我们同时使用Vue2和Vue3的小伙伴都能很快上手。</li>
<li>pinia中只有state、getter、action，抛弃了Vuex中的Mutation，Vuex中mutation一直都不太受小伙伴们的待见，pinia直接抛弃它了，这无疑减少了我们工作量。</li>
<li>pinia中action支持同步和异步，Vuex不支持</li>
<li>良好的Typescript支持，毕竟我们Vue3都推荐使用TS来编写，这个时候使用pinia就非常合适了</li>
<li>无需再创建各个模块嵌套了，Vuex中如果数据过多，我们通常分模块来进行管理，稍显麻烦，而pinia中每个store都是独立的，互相不影响。</li>
<li>体积非常小，只有1KB左右。</li>
<li>pinia支持插件来扩展自身功能。</li>
<li>支持服务端渲染。<br><a name="Mdnhg"></a></li>
</ul>
<h4 id="Pinia和VueX的区别"><a href="#Pinia和VueX的区别" class="headerlink" title="Pinia和VueX的区别"></a>Pinia和VueX的区别</h4><ol>
<li><strong>架构设计</strong></li>
</ol>
<p>Vuex是基于Flux架构的，将应用程序的状态存储在单个全局Store中，通过mutations、actions、getters等方式进行状态的修改、异步操作和计算。其中mutations是同步的，actions可以是异步的，用于处理异步操作和提交mutations，getters则用于从Store中获取数据。<br />而Pinia则是基于Vue3的Reactivity API的，它采用的是分散式的Store架构，每个Store拥有自己的状态、操作和计算逻辑，且可以懒加载使用。这种架构设计更加灵活，能够更好地满足组件开发的需求。</p>
<ol start="2">
<li><strong>使用方式</strong></li>
</ol>
<p>在Vuex中，我们需要先创建一个Store对象，并在Vue实例中注册，在组件中使用mapState、mapMutations、mapActions等辅助函数来访问Store中的状态和方法。<br />Pinia中则只需要定义Store类和相应的状态、操作和计算函数，然后在组件中使用useStore辅助函数来访问Store即可。Pinia还提供了一些辅助函数如mapStores、mapState等，与Vuex类似。</p>
<ol start="3">
<li><strong>TypeScript支持</strong></li>
</ol>
<p>Pinia天然支持TypeScript，通过泛型推断和接口定义来增强类型安全性，而Vuex需要使用vuex-module-decorators等辅助库来支持TypeScript。这使得在开发大规模应用时，Pinia更加适合。<br><a name="JjVD8"></a></p>
<h2 id="uniapp"><a href="#uniapp" class="headerlink" title="uniapp"></a>uniapp</h2><p><a name="WIJFf"></a></p>
<h3 id="小程序页面之间通信有几种方式"><a href="#小程序页面之间通信有几种方式" class="headerlink" title="小程序页面之间通信有几种方式"></a>小程序页面之间通信有几种方式</h3><ol>
<li>uni.emit和uni.on</li>
<li>uni.$refs</li>
<li>路由跳转携带参数<br><a name="YJgXk"></a></li>
</ol>
<h2 id="jQuery"><a href="#jQuery" class="headerlink" title="jQuery"></a>jQuery</h2><p><a name="ZNk86"></a></p>
<h3 id="jQuery动态绑定事件"><a href="#jQuery动态绑定事件" class="headerlink" title="jQuery动态绑定事件"></a>jQuery动态绑定事件</h3><p>就是给动态渲染的元素添加事件<br />回答：$(selector).on(‘click’,’span’,function(){})<br><a name="13c3d2f8"></a></p>
<h3 id="jquery获取dom对象是一个什么样的东西，怎么遍历？"><a href="#jquery获取dom对象是一个什么样的东西，怎么遍历？" class="headerlink" title="jquery获取dom对象是一个什么样的东西，怎么遍历？"></a>jquery获取dom对象是一个什么样的东西，怎么遍历？</h3><p>获取一个或多个 DOM 元素的 jQuery 对象<br />遍历：each()  其中可以使用 $(this) 或 jQuery(this) 来获取当前正在遍历的 DOM 元素的 jQuery 对象。<br><a name="85cc25d6"></a></p>
<h3 id="jquery给元素添加类名，自定义属性"><a href="#jquery给元素添加类名，自定义属性" class="headerlink" title="jquery给元素添加类名，自定义属性"></a>jquery给元素添加类名，自定义属性</h3><p>addclass()<br />attr()：可以设置和获取自定义属性<br><a name="Iwntk"></a></p>
<h2 id="ES6"><a href="#ES6" class="headerlink" title="ES6"></a>ES6</h2><p><a name="zxIlx"></a></p>
<h3 id="var、let和const的区别"><a href="#var、let和const的区别" class="headerlink" title="var、let和const的区别"></a>var、let和const的区别</h3><ol>
<li>变量提升<ol>
<li>var声明的变量存在变量提升，即变量可以在声明之前调用，值为undefined，let和const不存在变量提升，即它们所声明的变量一定要在声明后使用，否则报错</li>
</ol>
</li>
<li>暂时性死区<ol>
<li>var不存在暂时性死区，let和const存在暂时性死区，只有等到声明变量的那一行代码出现，才可以获取和使用该变量</li>
</ol>
</li>
<li>块级作用域<ol>
<li>var不存在块级作用域，let和const存在块级作用域</li>
</ol>
</li>
<li>重复声明<ol>
<li>var允许重复声明变量，let和const在同一作用域不允许重复声明变量</li>
</ol>
</li>
<li>修改声明的变量<ol>
<li>var和let可以修改声明的变量，const声明一个只读的常量。一旦声明，常量的值就不能改变</li>
</ol>
</li>
<li>使用场景<ol>
<li>能用const的情况尽量使用const，其他情况下大多数使用let，避免使用var<br><a name="KL1TJ"></a></li>
</ol>
</li>
</ol>
<h3 id="ES6有哪些遍历数组的方法"><a href="#ES6有哪些遍历数组的方法" class="headerlink" title="ES6有哪些遍历数组的方法"></a>ES6有哪些遍历数组的方法</h3><p>回答：</p>
<ol>
<li>forEach<ol>
<li>用于遍历数组,调用数组的每个元素,并将元素传递给回调函数进行处理</li>
</ol>
</li>
<li>map<ol>
<li>用于对数组中的每个元素调用指定的回调函数进行处理，并返回包含结果的数组</li>
</ol>
</li>
<li>filter<ol>
<li>对数组起过滤作用筛选出符合条件的一个或多个元素</li>
</ol>
</li>
<li>some<ol>
<li>检测数组中是否<strong>存在指定</strong>条件的元素；若存在指定的元素则返回的结果是true，若不存在指定的元素则返回的结果是false</li>
</ol>
</li>
<li>ecery<ol>
<li>判断数组中是否<strong>任意</strong>一个元素都符合判断条件，判断同样是在回调函数的函数体内完成，并由回调函数返回一个布尔值。如果回调函数在某次返回了false，则整个every方法返回false，且结束遍历。</li>
</ol>
</li>
<li>reduce<ol>
<li>为数组中的每一个元素依次执行回调函数，不包括数组中被删除或从未被赋值的元素，</li>
<li>接受四个参数：初始值（或者上一次回调函数的返回值），当前元素值，当前索引，调用<br><a name="WttCR"></a></li>
</ol>
</li>
</ol>
<h3 id="箭头函数能不能new"><a href="#箭头函数能不能new" class="headerlink" title="箭头函数能不能new"></a>箭头函数能不能new</h3><p><strong>不能！</strong><br />箭头函数是匿名函数,不能作为构造函数,不能使用new(否则报出的错为:fn is not a constructor)<br><a name="C8WbF"></a></p>
<h3 id="forin和forof的区别"><a href="#forin和forof的区别" class="headerlink" title="forin和forof的区别"></a>forin和forof的区别</h3><ol>
<li>for…of循环只能用于遍历实现了可迭代协议的集合，比如数组、字符串、Set、Map等，而不能用于遍历对象，因为对象不是可迭代的。</li>
<li>for…in循环会遍历对象自身及其原型链上的所有可枚举属性（包括继承的属性），而for…of循环只能遍历集合自身的元素，不能遍历继承的元素。<br><a name="hy1rs"></a></li>
</ol>
<h3 id="Promise是什么？"><a href="#Promise是什么？" class="headerlink" title="Promise是什么？"></a>Promise是什么？</h3><p>是JavaScript中的一个处理异步操作的对象，可以用来规避“回调地狱”问题。<br />有三种状态：pending、fulfilled 和 rejected 。当一个 Promise 对象创建时，它处于 pending 状态。当操作成功完成时会进入 fulfilled 状态，此时会调用 resolve 回调函数来处理操作结果；当操作失败时会进入 rejected 状态，此时会调用 reject 回调函数来处理错误信息。<br /><strong>“回调地狱”：</strong>是指在处理多个异步操作的时候，由于每个异步操作的执行顺序并不确定，因此需要在一个异步操作的回调函数中嵌套另一个异步操作，而这样的嵌套会导致代码结构异常复杂和难以维护<br><a name="uTkAE"></a></p>
<h4 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h4><p>resolve函数：用于将Promise对象的状态从“未完成”变为“成功”，并将异步操作的结果作为参数传递出去<br />reject函数：用于将Promise对象的状态从“未完成”变为“失败”，并将错误信息作为参数传递出去。<br><a name="pFG2F"></a></p>
<h4 id="Promise-all和Promise-allSettled"><a href="#Promise-all和Promise-allSettled" class="headerlink" title="Promise.all和Promise.allSettled"></a>Promise.all和Promise.allSettled</h4><ul>
<li><strong>Promise.all</strong>是一个并行执行多个Promise对象的方法，在所有Promise对象都成功时返回一个成功的Promise，如果其中一个Promise对象失败，则返回一个失败的Promise，并且会立即停止执行剩余的Promise对象。</li>
<li><strong>Promise.allSettled</strong>是一个并行执行多个Promise对象的方法，它会等待所有Promise对象都完成（无论成功或失败），并返回一个包含所有Promise对象状态的数组，每个元素都是一个对象，包含状态（fulfilled或rejected）和对应的值或原因。</li>
</ul>
<p>Promise.all 和 Promise.allSettled 都是用于处理多个 Promise 实例的方法，但具体使用场景略有不同。前者主要是等待多个异步操作完成并获取所有结果，而后者则不论 Promise 的状态如何，都会等待所有实例执行完毕，并将执行结果汇总到一个数组里。<br><a name="Oq13U"></a></p>
<h4 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h4><ul>
<li>执行方式不同：当所有 Promise 的状态都变为 resolved 或 rejected 时，Promise.all 才会返回结果；而 Promise.allSettled 会等待所有 Promise 都执行完成后返回结果，无论 Promise 的状态是 fulfilled 还是 rejected。</li>
<li>返回值不同：Promise.all 返回的是一个 Promise 实例，该实例会在所有 Promise 状态都变为 resolved 或 rejected 时，返回一个数组，包含所有 Promise 的结果。如果其中有任意一个 Promise 状态变为了 rejected，则返回的 Promise 实例状态也为 rejected。</li>
</ul>
<p>而 Promise.allSettled 返回的是一个 Promise 实例，该实例会在所有 Promise 都执行完成后，返回一个数组，该数组包含所有 Promise 的执行结果，不管是 rejected 还是 fulfilled。每个结果对象都有一个 status 属性，用来表示该 Promise 的状态（fulfilled 或 rejected），以及一个 value 或 reason 属性，分别表示该 Promise resolve 或 reject 时传递的参数。<br />因此，当我们需要等待多个异步操作都执行完成后获取所有结果时，可以使用 Promise.all。而当我们需要对多个异步操作的结果进行收集和汇总，无论其状态如何，都需要全部遍历一遍时，可以考虑使用 Promise.allSettled。<br><a name="F8mJJ"></a></p>
<h3 id="async和await和promise的区别"><a href="#async和await和promise的区别" class="headerlink" title="async和await和promise的区别"></a>async和await和promise的区别</h3><p>语法简洁明了：async&#x2F;await 采用 try…catch…块的结构来处理错误，从而使异步代码的实现和同步代码看起来一样简单。<br />更加优雅的错误处理：使用 async&#x2F;await 可以把异步操作的错误处理逻辑写在同步代码的 try…catch…块中，从而避免了 Promise 层层回调时的错误处理繁琐。<br />更好的可读性：采用 async&#x2F;await 的代码比 Promise 链式调用方式更加易读，不需要理解 Promise 和回调函数的原理和语法规则。<br><a name="IALmb"></a></p>
<h3 id="map和forEach的区别"><a href="#map和forEach的区别" class="headerlink" title="map和forEach的区别"></a>map和forEach的区别</h3><ol>
<li><strong>返回值：</strong>map()返回一个新的数组，其中包含当前数组中每个元素调用回调函数的结果。而forEach()没有返回值，它只是遍历数组并对每个元素执行一次回调函数。</li>
<li><strong>对原数组的影响：</strong>map()不会修改原始数组，它创建一个新的数组来存储回调函数的返回值。而forEach()在原始数组上直接修改，它不会创建新的数组。</li>
<li><strong>回调参数：</strong>map()和forEach()的回调函数都有三个参数：数组元素、元素索引和数组本身。但是，在map()中，回调函数还可以接受一个可选的第二个参数，表示回调函数执行时的this值。</li>
<li><strong>循环性能：</strong>在处理大型数组时，使用forEach()比使用map()更快，因为forEach()没有创建新数组的开销。</li>
</ol>
<p><strong>使用场景：</strong></p>
<ol>
<li>map方法适用于对数组中的元素进行转换，例如将一组数据处理成为另外一种格式，这些处理结果需要保存到一个新的数组中；</li>
<li>forEach方法则适用于需要遍历数组执行某些副作用操作（例如打印日志、发送请求等），并不需要生成新的数组。<br><a name="pjxvk"></a></li>
</ol>
<h2 id="HTML"><a href="#HTML" class="headerlink" title="HTML"></a>HTML</h2><p><a name="houpj"></a></p>
<h3 id="行级元素，块级元素，行内块元素"><a href="#行级元素，块级元素，行内块元素" class="headerlink" title="行级元素，块级元素，行内块元素"></a>行级元素，块级元素，行内块元素</h3><p>行级元素：通常用于包含或标记文本中的一部分内容，它们只占据其内容宽度的空间，不会强制进行换行。例如 a、span、em、i、b 等都是行级元素。<br />块级元素：在文档流中会占据一整行或一整块，可以容纳其他块级元素或行级元素，常用于页面布局。例如 div、p、h1-h6、nav、ul、ol、li 等都是块级元素<br />行内块元素：在外观上呈现为行级元素，但其内容具有块级元素的特性。它们不会强制进行换行，而是允许其他元素位于同一行内并共享水平空间。例如 img、input 等都是行内块级元素。<br><a name="CB5rB"></a></p>
<h3 id="回流和重绘"><a href="#回流和重绘" class="headerlink" title="回流和重绘"></a>回流和重绘</h3><p><strong>回流（Reflow）</strong>是指当DOM结构中的元素位置、大小或内容发生变化时，浏览器为了重新计算它们在文档中的准确位置和大小，需要重新布局整个文档树的过程。回流会耗费大量的计算资源，因为它涉及到对整个文档树的重新渲染。<br /><strong>重绘（Repaint）</strong>是指当元素的外观发生变化时，浏览器会将新的外观信息绘制到屏幕上的过程。重绘不涉及到文档树的重新计算，因此比回流消耗的资源要少很多。<br /><strong>常见的触发回流的操作：</strong></p>
<ol>
<li>页面首次渲染</li>
<li>浏览器窗口大小发生改变</li>
<li>元素的位置或大小发生变化</li>
<li>元素的内容发生变化</li>
</ol>
<p><strong>常见的触发重绘的操作：</strong></p>
<ol>
<li>修改元素的CSS样式</li>
<li>增删class属性<br><a name="cRDVa"></a></li>
</ol>
<h3 id="DOM事件流的整个流程"><a href="#DOM事件流的整个流程" class="headerlink" title="DOM事件流的整个流程"></a>DOM事件流的整个流程</h3><ol>
<li>捕获阶段</li>
<li>目标阶段</li>
<li>冒泡阶段</li>
<li>默认行为和取消行为<ol>
<li>通过调用 event.preventDefault() 方法或者返回 false 来取消默认行为。<br><a name="fr4Lx"></a></li>
</ol>
</li>
</ol>
<h3 id="Doctype作用"><a href="#Doctype作用" class="headerlink" title="Doctype作用"></a>Doctype作用</h3><!DOCTYPE html><p>声明位于文档的最前面，处于标签之前。告知浏览器的解析器，用什么文档类型规范来解析这个文档，Doctype不存在或者格式不正确都会导致文档以混杂模式呈现。<br><a name="AJQX2"></a></p>
<h2 id="CSS"><a href="#CSS" class="headerlink" title="CSS"></a>CSS</h2><p><a name="fKy0O"></a></p>
<h3 id="简单说一下盒子模型，以及标准情况和IE情况下的区别"><a href="#简单说一下盒子模型，以及标准情况和IE情况下的区别" class="headerlink" title="简单说一下盒子模型，以及标准情况和IE情况下的区别"></a>简单说一下盒子模型，以及标准情况和IE情况下的区别</h3><p>当对一个文档进行布局（layout）的时候，浏览器的渲染引擎会根据标准之一的 CSS 基础框盒模型（CSS basic box model），将所有元素表示为一个个矩形的盒子（box）。一个盒子由四个部分组成：content、padding、border、margin<br />标准盒子模型：width&#x2F;height 只是内容高度，不包含 padding 和 border值，都包含margin值<br />IE怪异盒子模型：width&#x2F;height 包含了 padding和 border值，都包含margin值<br><a name="kWSQL"></a></p>
<h3 id="三栏布局的方案"><a href="#三栏布局的方案" class="headerlink" title="三栏布局的方案"></a>三栏布局的方案</h3><p>三栏布局通常指的是一个header、一个main和一个footer，其中main一般又被分为左右两个侧边栏和中间主内容区。</p>
<ol>
<li>浮动布局(Float)：通过对header、main、footer进行浮动来实现三栏布局</li>
<li>弹性盒子布局(Flex)：通过使用flexbox布局来实现三栏布局，这种方案比浮动布局更加灵活且易于维护。</li>
<li>栅格布局(Grid)：通过使用栅格布局来实现三栏布局，这种方案也比较灵活，同时也可以支持更多列数的布局。<br><a name="aUcqw"></a></li>
</ol>
<h3 id="CSS尺寸设置的单位"><a href="#CSS尺寸设置的单位" class="headerlink" title="CSS尺寸设置的单位"></a>CSS尺寸设置的单位</h3><ol>
<li>px：px 就是 pixel 的缩写，意思是：像素</li>
<li>em：em的值并不是固定的，会继承父级元素的字体大小参考物是父元素的font-size（浏览器默认字体是16px），具有继承的特点。如果自身定义了 font-size 那么会按自身来计算，整个页面内1em不是一个固定的值。</li>
<li>rem：rem是相对于根元素 html，这样就意味着，我们只需要在根元素确定一个px字号，则可以来算出元素的宽高<ol>
<li>例如：a设备屏幕宽100，1rem &#x3D; 10px，b设备屏幕宽200，1rem自适应变为20px</li>
</ol>
</li>
<li>%：一般来说就是相对于父元素的</li>
<li>vw：css3新单位，view width的简写，是指可视窗口的宽度。<ol>
<li>举个例子：浏览器宽度 1920px，1vw &#x3D; 1920px &#x2F; 100 &#x3D; 19.2px</li>
</ol>
</li>
<li>vh：css3新单位，view height的简写，是指可视窗口的高度。<ol>
<li>举个例子：浏览器高度 900px，1vh &#x3D; 900px &#x2F; 100 &#x3D; 9px。</li>
</ol>
</li>
<li>vm：css3新单位，相对于视口的宽度或高度中较小的那个。最小的那个被均分为100单位的 vm<ol>
<li>举个例子：浏览器高度900px，宽度1200px，取最小的浏览器高度，1vm &#x3D; 900px &#x2F; 100 &#x3D; 9px。<br><a name="JkjMd"></a></li>
</ol>
</li>
</ol>
<h3 id="css隐藏元素的方法"><a href="#css隐藏元素的方法" class="headerlink" title="css隐藏元素的方法"></a>css隐藏元素的方法</h3><ol>
<li>display: none：渲染树不会渲染对象</li>
<li>visibility: hidden：元素在页面中仍占据空间，但是不会响应绑定的监听事件</li>
<li>opacity: 0：元素在页面中仍然占据空间，并且能够响应元素绑定的监听事件</li>
<li>position: absolute：通过使用绝对定位将元素移除可视区域内，以此来实现元素的隐藏。</li>
<li>z-index: 负值；：来使其他元素遮盖住该元素，以此来实现隐藏</li>
<li>clip&#x2F;clip-path:circle(0%)；：把元素裁剪出去，元素仍在页面中占据位置，但是不会响应绑定的监听事件</li>
<li>transform: scale(0,0)；： 将元素缩放为 0，元素仍在页面中占据位置，但是不会响应绑定的监听事件。</li>
<li>可以通过使用width、height、padding、border-width 或 font-size 来缩小元素的尺寸</li>
<li>transform 属性把元素平移出去<br><a name="IBtTS"></a></li>
</ol>
<h3 id="height和line-height的区别"><a href="#height和line-height的区别" class="headerlink" title="height和line-height的区别"></a>height和line-height的区别</h3><p>都是用于控制元素高度的属性<br /><strong>height（高度）：</strong>定义了元素盒模型的高度，它默认定义的是内容区域的高度，如果使用box-sizing属性设置为border-box，则表示高度是包括内边距和边框的。<br /><strong>line-height（行高）：</strong>定义了行框盒模型的高度，它作用于元素的文本内容，控制了每一行文本之间的高度间隔。在块级元素中，它定义了行盒模型的最小高度；在行内元素上，它定义了计算行盒模型高度所使用的高度值<br><a name="Jq0zq"></a></p>
<h3 id="calc-函数"><a href="#calc-函数" class="headerlink" title="calc()函数"></a>calc()函数</h3><p> CSS 中的一个计算值的函数，用于动态计算一些属性的值。<br />可以在 CSS 中的任何长度、百分比、角度和计数单位中使用。它使用加法、减法、乘法和除法等基本运算符对自定义表达式进行计算，并返回计算结果。<br />需要注意的是，calc() 函数中不同类型的值之间必须使用空格进行分隔<br><a name="w4H5x"></a></p>
<h3 id="元素垂直水平居中的几种方式"><a href="#元素垂直水平居中的几种方式" class="headerlink" title="元素垂直水平居中的几种方式"></a>元素垂直水平居中的几种方式</h3><ol>
<li>定位+transform</li>
<li>定位 + 负边距</li>
<li>弹性盒子</li>
<li>grid布局</li>
<li>table布局（比较老不怎么用）</li>
<li>margin:auto（需要知道元素的宽高）<br><a name="IqxSE"></a></li>
</ol>
<h3 id="样式优先级的规则是什么"><a href="#样式优先级的规则是什么" class="headerlink" title="样式优先级的规则是什么"></a>样式优先级的规则是什么</h3><ol>
<li>!important声明：具有最高优先级，会覆盖其它所有声明；</li>
<li>行内样式声明：其次是在 HTML 元素内部使用style属性所定义的样式声明；</li>
<li>ID选择器：优先级较高，比元素选择器和类选择器优先级要高；</li>
<li>类选择器、属性选择器、伪类选择器：这三者的优先级相等，如果存在多个，则按照它们的出现顺序来确定优先级；</li>
<li>元素选择器、伪元素选择器：优先级最低，只有在无其它选择器的情况下才会起作用。</li>
</ol>
<p><strong>注意：</strong>在优先级相同的情况下，后面定义的样式会覆盖前面的样式。另外，继承的样式优先级比普通样式低。<br><a name="PMry9"></a></p>
<h3 id="BFC"><a href="#BFC" class="headerlink" title="BFC"></a>BFC</h3><p>（块级格式化上下文），是CSS中的一个概念，它是指一个独立的块级渲染区域，具有一套渲染规则，用于控制内部块盒子的布局和表现形式。BFC常见的几种应用场景包括清除浮动、避免 margin 重叠等。<br />在BFC中，每个盒子的左边和右边必定会贴近其包含块盒子的左边和右边，这意味着，两个相邻的块级盒子之间即使有空白字符或者边框分隔，也不会有外边距重叠的问题。<br />BFC的触发条件有多种，最常见的是通过以下方式来触发：</p>
<ul>
<li>根元素；</li>
<li>float 的值不为 none；</li>
<li>position 的值为 absolute 或 fixed；</li>
<li>display 的值为 inline-block、table-cell、flex、grid 等；</li>
<li>overflow 的值不为 visible。<br><a name="p8p5P"></a></li>
</ul>
<h3 id="margin塌陷解决方案"><a href="#margin塌陷解决方案" class="headerlink" title="margin塌陷解决方案"></a>margin塌陷解决方案</h3><ol>
<li>使用border或padding来分隔元素间的margin：可以在父元素上设置border或padding，来防止其子元素的margin发生合并而相互影响</li>
<li>使用float属性：对于块级元素，使用float属性可以改变元素原有的布局方式，使得相邻元素不会再发生margin塌陷。但是，使用float可能会对页面布局造成影响，需要仔细考虑。</li>
<li>给父元素设置inline-block属性：使用该属性可以使父元素成为内联块级元素，在视觉效果上等同于”float:none”。它不会破坏原有的文档流，因此在某些情况下比使用float更为合适。</li>
<li>清除浮动：当元素浮动时，可能会对父元素的高度产生影响，导致无法正确计算margin的值。通过在父元素上应用”clearfix”类、增加”overflow:auto”或”overflow:hidden”属性等方式可以清除浮动，以达到正确计算margin的目的。</li>
<li>使用伪元素或空元素：可以使用伪元素（如:before和:after）或空元素（如<div class="clear"></div>）来占位，使得相邻元素的margin不会发生合并。这种方式在实际开发中比较常见。</li>
<li>使用flexbox布局：使用CSS flexbox布局可以解决一些margin塌陷问题，并且它比float更加灵活、容易控制。但是，需要注意的是flexbox并不是万能的解决方案，在一些特殊情况下可能还是会发生margin塌陷。<br><a name="KlYoL"></a></li>
</ol>
<h3 id="渐变"><a href="#渐变" class="headerlink" title="渐变"></a>渐变</h3><p><a name="H5zlE"></a></p>
<h4 id="线性渐变"><a href="#线性渐变" class="headerlink" title="线性渐变"></a>线性渐变</h4><p>要创建最基本的渐变类型，您只需指定两种颜色即可。这些被称为色标。至少指定两个色标，也可以指定任意数量。无需局限于使用两种颜色，你想使用多少种颜色都可以！默认情况下，所设置颜色会均匀分布在渐变路径中。<br />默认情况下，线性渐变的方向是从上到下，你可以指定一个值来改变渐变的方向。</p>
<pre><code class="css">background: linear-gradient(to right, blue, pink);				//从右往左渐变
background: linear-gradient(to bottom right, blue, pink);	//从一个对角到另一个对角
background: linear-gradient(70deg, blue, pink);						//给渐变设置一个具体的角度。
</code></pre>
<p>在使用角度的时候，0deg 代表渐变方向为从下到上，90deg 代表渐变方向为从左到右，诸如此类正角度都属于顺时针方向。而负角度意味着逆时针方向。<br><a name="ZZsf0"></a></p>
<h4 id="颜色终止位置"><a href="#颜色终止位置" class="headerlink" title="颜色终止位置"></a>颜色终止位置</h4><p>你可以通过给每个颜色设置 0，1% 或者 2% 或者其他的绝对数值来调整它们的位置。如果你将位置设置为百分数， 0% 表示起始点，而 100% 表示终点，但是如果需要的话你也可以设置这个范围之外的其他值来达到你想要的效果。</p>
<pre><code class="css"> background: linear-gradient(to left, lime 28px, red 77%, cyan);
</code></pre>
<p><a name="BhCbx"></a></p>
<h3 id="响应式布局方案"><a href="#响应式布局方案" class="headerlink" title="响应式布局方案"></a>响应式布局方案</h3><ol>
<li>媒体查询(Media Query)：使用CSS3中的@media规则根据不同的设备宽度调用不同的CSS样式</li>
<li>弹性盒子(Flexbox)：使用flexbox将页面分割为多个容器，在不同屏幕宽度下分别定位和排列这些容器以实现自适应</li>
<li>栅格系统(Grid System)：使用栅格系统将页面划分为等分的列，在不同屏幕宽度下显示不同数量的列<br><a name="kedG0"></a></li>
</ol>
<h3 id="定位的属性"><a href="#定位的属性" class="headerlink" title="定位的属性"></a>定位的属性</h3><ol>
<li>static：默认值，元素在正常文档流中显示，不进行特殊定位。</li>
<li>relative：相对定位，元素相对于其正常位置进行定位，通过 top、right、bottom 和 left 属性来控制定位的偏移量。</li>
<li>absolute：绝对定位，元素相对于其最近的非 static 祖先元素进行定位，如果不存在这样的祖先元素，则相对于 body 元素进行定位。通过 top、right、bottom 和 left 属性来控制定位的偏移量。</li>
<li>fixed：固定定位，元素相对于视口进行定位。通过 top、right、bottom 和 left 属性来控制定位的偏移量。</li>
<li>sticky：粘性定位，元素在滚动到特定位置时变为固定定位，相对于其容器进行定位。通过 top、right、bottom 和 left 属性来控制定位的偏移量。<br><a name="edf040c5"></a></li>
</ol>
<h3 id="flex给子元素写flex：1什么意思？"><a href="#flex给子元素写flex：1什么意思？" class="headerlink" title="flex给子元素写flex：1什么意思？"></a>flex给子元素写flex：1什么意思？</h3><p>作用是让子元素沿着主轴（flex-direction）自动填充剩余的可用空间。如果有多个子元素都设置了 <code>flex: 1</code>，它们将平均分配剩余的空间。<strong>例如：</strong>如果一个容器的宽度是 500px，里面有三个子元素，第一个子元素设置了宽度为 100px，第二个子元素设置了宽度为 200px，第三个子元素设置了 flex: 1，那么第三个子元素将自动填充剩余的 200px 宽度。<br />flex: 2 是设置子元素的 CSS 属性，它的作用是让子元素沿着主轴（flex-direction）自动填充剩余的可用空间，并且它的增长比例是 2，即比 flex: 1 的增长比例更大。<br><a name="a0d05240"></a></p>
<h3 id="怎么样清除浮动？"><a href="#怎么样清除浮动？" class="headerlink" title="怎么样清除浮动？"></a>怎么样清除浮动？</h3><ol>
<li>使用 overflow 属性清除浮动。可以给浮动元素的父容器添加 overflow:hidden 或 overflow:auto。这样可以使父容器生成一个 BFC（块格式化上下文），从而包含浮动元素。 </li>
<li>使用 clear 属性清除浮动。可以在浮动元素后面添加一个空元素，并给其设置 clear:both。这样可以清除前面的浮动元素，并换行显示。 </li>
<li>使用伪元素清除浮动。可以通过给浮动元素的父容器添加 ::after 伪元素来实现。具体做法是在父容器最后一个子元素后面添加一个伪元素，并给其设置 content:’’;、display:table;、clear:both；属性。 </li>
<li>父元素的高度设置为固定值。虽然这种方法并不推荐，但是在一些特殊情况下也可以使用。将浮动元素的父容器设置高度为固定值，就可以避免产生浮动问题。<br><a name="zkCGM"></a></li>
</ol>
<h2 id="原生JS"><a href="#原生JS" class="headerlink" title="原生JS"></a>原生JS</h2><p><a name="sQcqD"></a></p>
<h3 id="JS的严格模式"><a href="#JS的严格模式" class="headerlink" title="JS的严格模式"></a>JS的严格模式</h3><p>只需在js文件的最顶部添加”use strict”，即可开启js的严格模式<br />添加严格模式，主要有以下几个目的：</p>
<ul>
<li>消除 JavaScript 语法中一些不合理、不严谨的地方；</li>
<li>消除代码中一些不安全的地方，保证代码的安全运行；</li>
<li>提高 JavaScript 程序的运行效率；</li>
<li>为以后新版本的 JavaScript 做好铺垫。</li>
</ul>
<p><strong>严格模式的变化</strong></p>
<ol>
<li>不允许使用未声明的变量</li>
<li>不允许删除变量或函数</li>
<li>函数中不允许有同名的参数</li>
<li>eval 语句的作用域是独立的</li>
<li>不允许使用 with 语句</li>
<li>不允许写入只读属性</li>
<li>不允许使用八进制数</li>
<li>不能在 if 语句中声明函数</li>
<li>禁止使用 this 表示全局对象<br><a name="mz5nj"></a></li>
</ol>
<h3 id="普通函数跟箭头函数的区别"><a href="#普通函数跟箭头函数的区别" class="headerlink" title="普通函数跟箭头函数的区别"></a>普通函数跟箭头函数的区别</h3><ol>
<li>箭头函数没有自己的this</li>
<li>箭头函数没有arguments对象</li>
<li>箭头函数没有原型对象</li>
<li>箭头函数不能作为构造函数，不能new<br><a name="mOqte"></a></li>
</ol>
<h3 id="和-的区别"><a href="#和-的区别" class="headerlink" title="&#x3D;&#x3D;和&#x3D;&#x3D;&#x3D;的区别"></a>&#x3D;&#x3D;和&#x3D;&#x3D;&#x3D;的区别</h3><ol>
<li>“&#x3D;&#x3D;”叫做相等运算符，”&#x3D;&#x3D;&#x3D;”叫做严格运算符。</li>
<li>&#x3D;&#x3D;：等同的意思，两边值类型不同的时候，要先进行类型转换为同一类型后，再比较值是否相等。值相等即可为真</li>
<li>&#x3D;&#x3D;&#x3D;：恒等的意思，不做类型转换，类型不同的结果一定不等。要求不仅值相等，而且也要求类型相同<br><a name="ZjI3i"></a></li>
</ol>
<h3 id="null和undefined的区别"><a href="#null和undefined的区别" class="headerlink" title="null和undefined的区别"></a>null和undefined的区别</h3><p>null：null表示一个被明确地赋值为null的变量，即该变量的值为空值<br />undefined：undefined表示一个声明了但未赋值的变量，或者一个并不存在的对象属性<br><a name="Pkftj"></a></p>
<h3 id="深拷贝，浅拷贝"><a href="#深拷贝，浅拷贝" class="headerlink" title="深拷贝，浅拷贝"></a>深拷贝，浅拷贝</h3><p><strong>浅拷贝：</strong>指的是创建新的数据，这个数据有着原始数据属性值的一份精确拷贝，如果属性是基本类型，拷贝的就是基本类型的值。如果属性是引用类型，拷贝的就是内存地址<br />这意味着，当原始对象或数组发生改变时，复制对象或数组也会跟着改变。浅拷贝通常用于需要复制对象或数组部分属性或元素的场景。<br /><strong>深拷贝：</strong>深拷贝开辟一个新的栈，两个对象属完成相同，但是对应两个不同的地址，修改一个对象的属性，不会改变另一个对象的属性。深拷贝通常用于需要完整复制对象或数组及其所有属性或元素的场景。<br><a name="Mkeun"></a></p>
<h4 id="实现深拷贝方法"><a href="#实现深拷贝方法" class="headerlink" title="实现深拷贝方法"></a>实现深拷贝方法</h4><ol>
<li>递归拷贝：递归遍历需要拷贝的对象，并创建一个新对象来保存原始对象的值。如果属性的值是一个Object类型，则递归地拷贝该子对象。</li>
<li>使用JSON序列化和反序列化：首先使用JSON.stringify()把对象转换为字符串，然后再使用JSON.parse()方法把该字符串转换回对象。<ol>
<li>缺点：这种方式可以处理简单数据类型和对象，但是无法处理函数和循环引用的对象。<br><a name="h4aoQ"></a></li>
</ol>
</li>
</ol>
<h4 id="实现浅拷贝方法"><a href="#实现浅拷贝方法" class="headerlink" title="实现浅拷贝方法"></a>实现浅拷贝方法</h4><ol>
<li>使用Object.assign()方法：该方法接收一个目标对象和一个或多个源对象作为参数，并返回目标对象。当有多个源对象时，后续的源对象的属性将覆盖前面的源对象的属性。此方法会复制原始对象的可枚举属性和值，但是不会复制原型链上的属性和方法。</li>
<li>使用展开运算符（…）：该运算符将一个数组或对象展开成一个或多个参数。我们可以将原始对象展开到一个新对象中，从而进行浅拷贝。<br><a name="b4fCe"></a></li>
</ol>
<h4 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h4><p>以下是一些深浅拷贝的应用场景：</p>
<ol>
<li>浅拷贝可以用于缓存数据。缓存数据时，使用浅拷贝可以节省内存空间，因为每次只复制对象或数组的引用。</li>
<li>深拷贝可以用于复制JSON数据。由于JSON数据都是基本类型的键值对，因此可以通过JSON.parse和JSON.stringify来实现深拷贝。</li>
<li>深拷贝可以用于实现数据的备份、撤销、恢复等功能。当用户对数据进行编辑时，可以先深拷贝数据并保存到历史数据中，以便撤销操作时恢复原始数据。</li>
<li>深拷贝可以用于数据传递。当需要创建一个独立的对象或数组来存储数据时，可以使用深拷贝，以防止修改原始数据。</li>
<li>浅拷贝可以用于在两个不同的变量之间共享数据。当浅拷贝一个对象或数组时，两个变量将共享同一个对象或数组的引用，因此它们可以同时访问和修改数据。<br><a name="bKyfA"></a></li>
</ol>
<h3 id="call-、-apply-和bind-的区别"><a href="#call-、-apply-和bind-的区别" class="headerlink" title=".call()、.apply()和bind()的区别"></a>.call()、.apply()和bind()的区别</h3><ol>
<li>call()、apply()和bind()都是JavaScript中的函数方法，用于改变函数的执行上下文（this指向）。</li>
<li>call()和apply()可以立即调用一个函数，而且可以将对象作为参数传递给该函数，并在调用时指定执行上下文。</li>
<li>call()和apply()的区别在于方法接受参数的方式不同。call()方法接受单个参数列表，而apply()方法接收数组参数。</li>
<li>bind()则是在绑定后返回一个新函数，可以在稍后被调用。<br><a name="oQQIW"></a></li>
</ol>
<h3 id="闭包是什么，有什么特性，对页面有什么影响"><a href="#闭包是什么，有什么特性，对页面有什么影响" class="headerlink" title="闭包是什么，有什么特性，对页面有什么影响"></a>闭包是什么，有什么特性，对页面有什么影响</h3><p><strong>是什么：</strong>一般来说，JavaScript 中的函数只能访问自己作用域以及全局作用域中的变量，访问不到其他函数作用域内的变量。但是，如果将一个函数作为另一个函数的返回值时，内部函数就可以访问外部函数的变量或参数，这种机制就是闭包。<br /><strong>特性：</strong></p>
<ol>
<li>封闭性：外界无法访问闭包内部的数据，如果在闭包内声明变量，外界是无法访问的，除非闭包主动向外 界提供访问接口；</li>
<li>持久性：一般的函数，调用完毕之后，系统自动注销函数，而对于闭包来说，在外部函数被调 用之后，闭包结构依然保存在；</li>
</ol>
<p><strong>对页面的影响：</strong>使用闭包会占有内存资源，过多的使用闭包会导致内存溢出等<br><a name="EKSdq"></a></p>
<h4 id="闭包的使用场景"><a href="#闭包的使用场景" class="headerlink" title="闭包的使用场景"></a>闭包的使用场景</h4><ol>
<li>防抖和节流。通过使用闭包来缓存上一次操作的时间戳或计数器等变量，实现防抖（debounce）和节流（throttle）的功能。</li>
<li>计数器和累加器。使用闭包可以轻松地创建计数器和累加器，因为闭包可以保存变量的状态。</li>
<li>事件处理程序。使用闭包可以把事件处理程序封装在一个函数内部，并保存对相关数据的引用，从而实现更灵活的事件处理方式。<br><a name="M7oos"></a></li>
</ol>
<h3 id="内存泄漏"><a href="#内存泄漏" class="headerlink" title="内存泄漏"></a>内存泄漏</h3><p>通常是由于以下原因导致的：</p>
<ol>
<li>全局变量。全局变量会存在于整个应用程序的生命周期中，如果不手动删除它们，就会一直占用内存。</li>
<li>闭包。当函数内部的变量或函数引用了外部函数的变量时，这些变量或函数就会被保存在内存中，如果不及时清除，就会导致内存泄漏。</li>
<li>DOM元素引用。当我们移除DOM节点时，并没有去掉节点对JavaScript对象的引用，导致对象无法被垃圾回收机制回收。</li>
<li>定时器和事件监听器。如果没有清除永久性定时器或事件监听器，那么它们将一直存在于内存中，直到页面被卸载。</li>
</ol>
<p><strong>造成的后果：</strong></p>
<ol>
<li>程序变慢。当占用内存过多时，程序的运行速度会变慢，因为操作系统需要不断地对内存进行交换和回收。</li>
<li>内存溢出。如果内存不断被占用而无法释放，就可能导致内存溢出，并导致程序崩溃。</li>
<li>系统崩溃。当内存占用过高时，操作系统可能会强制关闭应用程序或整个系统，从而导致系统崩溃。</li>
<li>安全问题。当程序发生内存泄漏时，可能会暴露敏感数据，如密码、密钥等，这会增加程序被攻击的风险。</li>
<li>用户体验下降。当程序变慢或崩溃时，用户无法正常使用应用程序，这会影响用户体验，降低用户满意度。<br><a name="epKLs"></a></li>
</ol>
<h4 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h4><ol>
<li>避免创建全局变量和未清除的变量引用。</li>
<li>避免形成不必要的闭包，尽量减少使用闭包。</li>
<li>在移除DOM节点时，及时清除节点对JavaScript对象的引用。</li>
<li>在使用定时器和事件监听器时，使用setInterval()代替setTimeout()，并在页面被卸载时，使用clearInterval()和removeEventListener()手动清除。</li>
<li>使用Chrome开发者工具等工具进行内存泄漏分析，找出问题所在并及时修复。<br><a name="EFU0p"></a></li>
</ol>
<h3 id="判断变量类型的方法"><a href="#判断变量类型的方法" class="headerlink" title="判断变量类型的方法"></a>判断变量类型的方法</h3><ol>
<li>typeof ：用于判断给定变量的数据类型。它返回一个字符串，表示这个变量的数据类型<ol>
<li>typeof无法判断null和数组，它将null判断为“object”类型，将数组判断为“object”类型。</li>
</ol>
</li>
<li>instanceof ：instanceof操作符用于检查某个对象是否属于某个类或某个构造函数的实例。<ol>
<li>需要注意的是，instanceof只能判断对象类型。</li>
</ol>
</li>
<li>Object.prototype.toString()：该方法是Object原型上的方法，可以返回调用该方法的对象的类型信息</li>
<li>Array.isArray()：isArray()方法用于判断某个对象是否为数组，如果是则返回true，否则返回false。<ol>
<li>需要注意的是，isArray()方法只能判断是否为数组类型。<br><a name="JDSyL"></a></li>
</ol>
</li>
</ol>
<h3 id="JS继承的方法和优缺点"><a href="#JS继承的方法和优缺点" class="headerlink" title="JS继承的方法和优缺点"></a>JS继承的方法和优缺点</h3><ol>
<li>原型链继承：利用原型链实现继承。子类通过修改其原型对象来继承父类的属性和方法。优点是简单易懂，缺点是父类中的引用类型属性会在所有实例之间共享。</li>
<li>构造函数继承：在子类构造函数中使用apply或call方法来调用父类构造函数，并绑定子类实例上下文，从而实现继承。优点是可以向父类传递参数，缺点是无法继承父类原型链上的属性和方法。</li>
<li>组合式继承：结合原型链继承和借用构造函数的优点，既可以继承父类原型链上的方法，又可以向父类传递参数。但是缺点是会调用两次父类构造函数，导致性能问题。</li>
<li>原型式继承：通过创建一个空对象作为中介，然后将该对象的原型指向父类实例来实现继承。优点是简单易懂，缺点是对于引用类型的属性仍然会存在共享的问题。</li>
<li>寄生式组合继承：与组合继承类似，但是通过Object.create方法来代替借用构造函数来实现继承，从而避免了调用父类构造函数两次的性能问题。<br><a name="xQyMM"></a></li>
</ol>
<h3 id="JS实现异步的方法"><a href="#JS实现异步的方法" class="headerlink" title="JS实现异步的方法"></a>JS实现异步的方法</h3><ol>
<li><strong>回调函数：</strong>回调函数是一种常见的异步编程方式，即将一个函数作为参数传递给另一个函数，在第一个函数执行完成后，再调用该函数进行处理。</li>
<li><strong>Promise 对象：</strong>Promise 对象是 ES6 新增的接口，它可以更优雅地处理异步操作。Promise 对象可以将回调函数的成功和失败两种情况分开处理，并且可以链式调用，更易于阅读和维护。</li>
<li><strong>async&#x2F;await：</strong>async&#x2F;await 是 ES7 中新增的特性，它可以更方便地编写异步代码，让异步操作的语法更像同步代码。async&#x2F;await 基于 Promise，使用起来非常简单，只需要在异步函数前加上async关键字，然后在异步操作中使用await关键字。<br><a name="Cc7C9"></a></li>
</ol>
<h3 id="冒泡和捕获"><a href="#冒泡和捕获" class="headerlink" title="冒泡和捕获"></a>冒泡和捕获</h3><p>冒泡（Bubbling）：</p>
<ol>
<li>冒泡是指从事件发生的元素开始，逐级向上层元素传播（冒泡到父级元素、祖父级元素等），直至传播到DOM树的根节点。</li>
<li>当一个元素触发了某个事件时，它的父级元素都会收到相同的事件，并按照嵌套关系逐级触发。</li>
<li>冒泡阶段可以通过调用event.stopPropagation()方法来停止继续向上冒泡。</li>
</ol>
<p>捕获（Capturing）：</p>
<ol>
<li>捕获是指从DOM树的根节点开始，逐级向下层元素传播（捕获到子级元素、孙子级元素等），直至传播到事件发生的元素。</li>
<li>在捕获阶段，事件从根节点逐级向下传播，直到达到事件发生的元素。</li>
<li>捕获阶段不可以被阻止。</li>
</ol>
<p>冒泡和捕获阶段可以通过使用addEventListener方法来指定。该方法有三个参数：事件类型、事件处理函数和一个布尔值，用于指定事件是在冒泡阶段还是捕获阶段被处理。布尔值为true时表示在捕获阶段处理，为false（默认值）时表示在冒泡阶段处理。<br><a name="Wehlk"></a></p>
<h3 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h3><p>在JS中，有两种类型的作用域：全局作用域和局部作用域。全局作用域中定义的变量和函数可以被代码中的任何部分访问，而局部作用域中定义的变量和函数只能被特定的代码片段访问。<br />在ES6中，JS新增了块级作用域（block scope），即使用let或const声明的变量和常量的作用域为所在的块级作用域<br><a name="U0QvF"></a></p>
<h3 id="作用域链"><a href="#作用域链" class="headerlink" title="作用域链"></a>作用域链</h3><p>JS作用域链（Scope Chain）是指在当前函数中访问一个变量时，会先从当前函数的作用域开始查找该变量，如果该变量没有定义在该作用域下，则会沿着函数定义时所在的作用域一层一层向上查找，直到全局作用域，这个过程中形成的链式结构就是作用域链。<br><a name="U4FZS"></a></p>
<h3 id="防抖和节流"><a href="#防抖和节流" class="headerlink" title="防抖和节流"></a>防抖和节流</h3><p>所谓防抖，就是指触发事件后在规定时间内只执行一次，如果在规定时间内再次触发该事件，那么就重新计算时间<br />所谓节流，就是指连续触发事件但是在 n 秒内只执行一次函数。<br><a name="Bp5N2"></a></p>
<h3 id="new操作符做了什么"><a href="#new操作符做了什么" class="headerlink" title="new操作符做了什么"></a>new操作符做了什么</h3><ol>
<li>创建一个空对象。</li>
<li>将新对象的原型设置为构造函数的原型（即将新对象链接到构造函数的原型链上）。</li>
<li>将构造函数的作用域赋给新对象（因此在构造函数内部可以使用”this”关键字来引用新对象）。</li>
<li>执行构造函数，并传递任何参数。</li>
<li>如果构造函数返回一个非空对象，则返回该对象；否则，返回新创建的对象。<br><a name="FPBV0"></a></li>
</ol>
<h3 id="操作Cookie"><a href="#操作Cookie" class="headerlink" title="操作Cookie"></a>操作Cookie</h3><p>在JavaScript中，操作cookies可以通过document对象的cookie属性来实现。cookie是一种小型的文本文件，存储于客户端，由服务器通过HTTP响应的Set-Cookie头部将其发送到浏览器上。</p>
<ol>
<li>设置cookie：可以通过给document.cookie属性赋值来设置cookie。例如：</li>
</ol>
<pre><code class="vue">document.cookie = &quot;username=binjie09&quot;;
</code></pre>
<p>这样会将名为”username”的cookie设置为”binjie09”，有效期默认为会话结束后清除。</p>
<ol start="2">
<li>如果要设置过期时间和路径等属性，可以使用如下方式：</li>
</ol>
<pre><code class="vue">var expiresDate = new Date();
expiresDate.setTime(expiresDate.getTime() + (24 * 60 * 60 * 1000)); // 有效期为一天
document.cookie = &quot;username=binjie09; expires=&quot; + expiresDate.toUTCString() + &quot;; path=/&quot;;
</code></pre>
<p>这样就设置了一个名为”username”的cookie，有效期为一天，并且仅在根路径下可见。</p>
<ol start="3">
<li>读取cookie：可以通过document.cookie来读取所有的cookie，然后对其进行解析。例如：</li>
</ol>
<pre><code class="vue">var cookies = document.cookie.split(&quot;; &quot;);
for(var i = 0; i &lt; cookies.length; i++) &#123;
  var cookie = cookies[i].split(&quot;=&quot;);
  console.log(cookie[0] + &quot;: &quot; + cookie[1]);
&#125;
</code></pre>
<p>这样就会输出所有的cookie以及对应的值。</p>
<ol start="4">
<li>删除cookie：可以将cookie的过期时间设置为一个过去的时间来删除cookie。例如：</li>
</ol>
<pre><code class="vue">var expiresDate = new Date();
expiresDate.setTime(expiresDate.getTime() - 1);
document.cookie = &quot;username=; expires=&quot; + expiresDate.toUTCString() + &quot;; path=/&quot;;
</code></pre>
<p>这样就将名为”username”的cookie删除了<br><a name="DVqMF"></a></p>
<h3 id="宏任务和微任务"><a href="#宏任务和微任务" class="headerlink" title="宏任务和微任务"></a>宏任务和微任务</h3><p>JS是一门<strong>单线程</strong>的语言，这是因为它运行在浏览器的<strong>渲染主线程中</strong>，而渲染主线程只有一个。而渲染主线程承担着诸多的工作，渲染页面、执行 JS 、解析页面、解析CSS等都在其中运行。为了不造成主线程阻塞就有了同步任务跟异步任务，而宏任务和微任务都是异步任务，属于一个消息队列。<br><a name="NUp0B"></a></p>
<h4 id="执行顺序："><a href="#执行顺序：" class="headerlink" title="执行顺序："></a><strong>执行顺序：</strong></h4><p>先执行同步代码，遇到异步宏任务则将异步宏任务放入宏任务队列中，遇到异步微任务则将异步微任务放入微任务队列中，当所有同步代码执行完毕后，再将异步微任务从队列中调入主线程执行，微任务执行完毕后再将异步宏任务从队列中调入主线程执行，一直循环直至所有任务执行完毕。<br><a name="Xeamh"></a></p>
<h4 id="宏任务和微任务有哪些？"><a href="#宏任务和微任务有哪些？" class="headerlink" title="宏任务和微任务有哪些？"></a>宏任务和微任务有哪些？</h4><ol>
<li>宏任务一般是：script、setTimeout、setInterval、postMessage、MessageChannel、setImmediate(Node.js 环境)</li>
<li>微任务：Promise.then、Object.observe、MutationObserver、process.nextTick(Node.js 环境)<br><a name="sw6zz"></a></li>
</ol>
<h3 id="addeventlister-方法参数中的函数为什么不能是匿名函数"><a href="#addeventlister-方法参数中的函数为什么不能是匿名函数" class="headerlink" title="addeventlister()方法参数中的函数为什么不能是匿名函数"></a>addeventlister()方法参数中的函数为什么不能是匿名函数</h3><p>原生js addeventlister方法参数中的函数可以是匿名函数，但是如果需要在后续的操作中移除该事件监听器，就无法移除匿名函数，因为无法引用它。因此，建议使用具名函数作为事件监听器，这样可以方便地在后续操作中移除它。<br><a name="aYS8z"></a></p>
<h2 id="小程序"><a href="#小程序" class="headerlink" title="小程序"></a>小程序</h2><p><a name="AI9bX"></a></p>
<h3 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h3><ol>
<li>应用的生命周期<ol>
<li>onLaunch：小程序初始化完成时触发，全局只触发一次。</li>
<li>onShow：小程序启动或从后台进入前台显示时触发。</li>
<li>onHide：小程序从前台进入后台时触发。</li>
<li>onError：小程序发生脚本错误或 API 调用失败时触发。</li>
</ol>
</li>
<li>页面的生命周期<ol>
<li>onLoad：页面加载时触发。</li>
<li>onShow：页面显示时触发。</li>
<li>onRead：页面初次渲染完成时触发。</li>
<li>onHide：页面隐藏时触发。</li>
<li>onUnload：页面卸载（销毁）时触发。</li>
</ol>
</li>
<li>组件的生命周期<ol>
<li>created：组件实例化时触发。</li>
<li>attached：组件被添加到页面中时触发。</li>
<li>ready：组件初始化完成时触发。</li>
<li>moved：组件移动到另一个节点时触发。</li>
<li>detached：组件被移除出页面时触发。<br><a name="qR9re"></a></li>
</ol>
</li>
</ol>
<h3 id="路由跳转API"><a href="#路由跳转API" class="headerlink" title="路由跳转API"></a>路由跳转API</h3><ul>
<li>navigateTo 	保留导航历史记录，可后退到原页面。</li>
<li>redirectTo 	关闭原页面，不保留导航历史记录。</li>
<li>switchTab	切换到底部导航栏的指定页面，关闭其他页面。</li>
<li>reLaunch 	关闭所有页面，并打开新页面。<br><a name="Ebj4w"></a></li>
</ul>
<h4 id="区别-1"><a href="#区别-1" class="headerlink" title="区别"></a>区别</h4><ol>
<li>navigateTo: 使用navigateTo方法可以进行页面跳转，并保留原页面的导航历史记录。跳转后用户可以通过后退按钮返回上一个页面。这个方法适合用于普通的页面跳转。</li>
<li>redirectTo: redirectTo方法也用于页面跳转，但是它会关闭当前页面，并且不保存导航历史记录。所以用户无法通过后退按钮返回原页面。这个方法适合用于不需要保留原页面的跳转场景。</li>
<li>switchTab: 使用switchTab方法可以切换到底部导航栏中的指定页面。它会关闭其他非标签页的页面，并且不保存导航历史记录。这个方法适用于底部导航栏切换页面的场景。</li>
<li>reLaunch: reLaunch方法用于关闭所有页面，打开新页面。它类似于应用程序的重新启动，不保存导航历史记录。这个方法适用于重新加载应用程序或者进行重置操作的场景。<br><a name="bp6yM"></a></li>
</ol>
<h3 id="小程序登录流程"><a href="#小程序登录流程" class="headerlink" title="小程序登录流程"></a>小程序登录流程</h3><ol>
<li>用户点击登录按钮或者需要登录的功能，微信小程序会调用微信提供的 wx.login 方法获取用户的 code 临时登录凭证。</li>
<li>小程序开发者服务器使用获取到的 code，向微信服务器发送 https 请求，将 code 交换成 openid 和 session_key。其中，openid 是每个用户在小程序中唯一的标识，而 session_key 是微信用于加密数据的一个关键参数。</li>
<li>小程序开发者服务器将获取到的 openid 和 session_key 返回给小程序前端。</li>
<li>小程序前端将 openid 和 session_key 储存在本地，并获取到微信提供的 wx.getUserInfo 方法来获取用户的基本信息，例如用户头像、昵称等。</li>
<li>小程序前端将获取到的用户信息和 openid 一同传递给小程序开发者服务器，以便服务器使用 openid 储存和管理用户信息。</li>
<li>当用户再次打开小程序时，小程序前端会检查本地是否已经存储有 openid 和 session_key，如果已经存在则直接使用；否则需要进行重新的登录流程。<br><a name="pMIVI"></a></li>
</ol>
<h2 id="TypeScript"><a href="#TypeScript" class="headerlink" title="TypeScript"></a>TypeScript</h2><p><a name="XaWk2"></a></p>
<h3 id="JavaScript和TypeScript的区别"><a href="#JavaScript和TypeScript的区别" class="headerlink" title="JavaScript和TypeScript的区别"></a>JavaScript和TypeScript的区别</h3><ol>
<li>类型系统：JavaScript 是一种弱类型语言，变量的类型可以随意更改。而 TypeScript 是一种强类型的语言，需要声明变量的类型，并保证在编译时变量类型的正确性。</li>
<li>编译器：JavaScript 不需要编译器，我们直接使用浏览器或 Node.js 运行即可，而 TypeScript 需要通过 TypeScript 编译器将 TypeScript 代码编译为 JavaScript 代码后才能运行。</li>
<li>语法扩展：TypeScript 是 JavaScript 的超集，可以使用所有 JavaScript 的语法和 API，同时还提供了一些新的语言特性，如类、接口、命名空间等。</li>
<li>开发体验：由于 TypeScript 具备类型检查的能力，在开发过程中可以发现一些潜在的问题，这可以提高代码的健壮性和可维护性。此外，TypeScript 还提供了丰富的编辑器支持和错误提示，可以帮助我们更快地定位错误和调试代码。<br><a name="Z3ZZR"></a></li>
</ol>
<h3 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h3><p>泛型是一种用于定义函数、类或接口的特殊类型，它可以在编译时期不确定具体类型，而是在运行时期由用户来指定。通过使用泛型，可以增强代码的复用性和扩展性。<br />泛型的语法格式是在函数名称后添加尖括号，尖括号中包含若干个泛型参数，这些泛型参数可以用于描述函数参数、返回值或者类成员变量的类型。<br><a name="GvUo7"></a></p>
<h3 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h3><p>接口是一种用于描述对象结构的类型，它定义了一个对象应该包含哪些属性、方法以及其对应的类型。通过使用接口，可以提高代码的可读性和可维护性。<br />接口的语法格式是使用interface关键字定义<br><a name="jUvBZ"></a></p>
<h2 id="react"><a href="#react" class="headerlink" title="react"></a>react</h2><p><a name="jvktS"></a></p>
<h3 id="Hook"><a href="#Hook" class="headerlink" title="Hook"></a>Hook</h3><p>Hook通常被用于实现组件之间的通信、状态管理和生命周期函数的执行等功能。<br />在React中，Hooks为函数组件引入了状态管理、副作用处理等功能。React提供了几个不同的Hook，包括：</p>
<ul>
<li>useState: 用于在函数组件中添加状态管理的能力</li>
<li>useEffect: 用于在函数组件中处理副作用（如发送网络请求，添加&#x2F;删除DOM元素等）</li>
<li>useContext: 用于在函数组件中访问Context状态</li>
<li>useReducer: 用于在函数组件中添加一个类似Redux的状态管理功能</li>
<li>useCallback: 用于在函数组件中缓存函数实例，避免不必要的重新渲染</li>
<li>useMemo: 用于在函数组件中缓存计算结果，避免不必要的计算开销</li>
</ul>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="http://example.com">sssc</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://example.com/2023/07/20/%E9%9D%A2%E8%AF%95%E9%A2%98/">http://example.com/2023/07/20/%E9%9D%A2%E8%AF%95%E9%A2%98/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://example.com" target="_blank">sssc & 博客</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"></div><div class="post_share"><div class="social-share" data-image="/img/avatar.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><div class="post-reward"><div class="reward-button"><i class="fas fa-qrcode"></i> 打赏</div><div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="/img/wxPay.jpg" target="_blank"><img class="post-qr-code-img" src="/img/loading.gif" data-original="/img/wxPay.jpg" alt="微信"/></a><div class="post-qr-code-desc">微信</div></li><li class="reward-item"><a href="/img/zfbPay.jpg" target="_blank"><img class="post-qr-code-img" src="/img/loading.gif" data-original="/img/zfbPay.jpg" alt="支付宝"/></a><div class="post-qr-code-desc">支付宝</div></li></ul></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-full"><a href="/2023/07/21/git%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/" title="git的基本操作"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">git的基本操作</div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/loading.gif" data-original="/img/avatar.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">sssc</div><div class="author-info__description">轻舟已过万重山</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">5</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">0</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/sssc0"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/sssc0" target="_blank" title="Github"><i class="fab fa-github" style="color: #24292e;"></i></a><a class="social-icon" href="mailto:1012951906@qq.com" target="_blank" title="Email"><i class="fas fa-envelope" style="color: #4a7dbe;"></i></a><a class="social-icon" href="tencent://AddContact/?fromId=45&amp;fromSubId=1&amp;subcmd=all&amp;uin=1012951906&amp;website=www.oicqzone.com" target="_blank" title="QQ"><i class="fab fa-qq"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">最近无公告</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A1%B9%E7%9B%AE"><span class="toc-number">1.</span> <span class="toc-text">项目</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A1%B9%E7%9B%AE%E7%9A%84%E4%B8%8A%E7%BA%BF%E6%B5%81%E7%A8%8B"><span class="toc-number">1.1.</span> <span class="toc-text">项目的上线流程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A1%B9%E7%9B%AE%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96"><span class="toc-number">1.2.</span> <span class="toc-text">项目性能优化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#MVVM%E7%90%86%E8%A7%A3"><span class="toc-number">1.3.</span> <span class="toc-text">MVVM理解</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#MVC%E7%90%86%E8%A7%A3"><span class="toc-number">1.4.</span> <span class="toc-text">MVC理解</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#MVC%E5%92%8CMVVM%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">1.5.</span> <span class="toc-text">MVC和MVVM的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E7%9A%84%E5%8F%8C%E5%90%91%E7%BB%91%E5%AE%9A%E5%92%8CVue%E7%9A%84%E5%8F%8C%E5%90%91%E7%BB%91%E5%AE%9A%E5%93%AA%E9%87%8C%E4%B8%8D%E4%B8%80%E6%A0%B7"><span class="toc-number">1.6.</span> <span class="toc-text">微信小程序的双向绑定和Vue的双向绑定哪里不一样</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B2%99%E7%AE%B1%E9%9A%94%E7%A6%BB"><span class="toc-number">1.7.</span> <span class="toc-text">沙箱隔离</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%99%9A%E6%8B%9F%E5%88%97%E8%A1%A8%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%8C%E9%A1%B9%E7%9B%AE%E4%B8%AD%E6%9C%89%E5%93%AA%E4%BA%9B%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-number">1.8.</span> <span class="toc-text">虚拟列表是什么，项目中有哪些应用场景</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0%E6%80%9D%E8%B7%AF"><span class="toc-number">1.8.1.</span> <span class="toc-text">实现思路</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B0%88%E8%B0%88%E4%BD%A0%E5%AF%B9%E6%B8%90%E8%BF%9B%E5%BC%8F%E6%A1%86%E6%9E%B6%E7%9A%84%E7%90%86%E8%A7%A3"><span class="toc-number">1.9.</span> <span class="toc-text">谈谈你对渐进式框架的理解</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%8B%E5%8D%95%E5%8A%9F%E8%83%BD%E6%A8%A1%E5%9D%97%E4%B8%AD%E6%80%8E%E4%B9%88%E9%99%90%E5%88%B6%E9%87%8D%E5%A4%8D%E6%8F%90%E4%BA%A4%E8%AE%A2%E5%8D%95"><span class="toc-number">1.10.</span> <span class="toc-text">下单功能模块中怎么限制重复提交订单</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%AB%98%E5%86%85%E8%81%9A%E4%BD%8E%E8%80%A6%E5%90%88"><span class="toc-number">1.11.</span> <span class="toc-text">高内聚低耦合</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8D%95%E9%A1%B5%E9%9D%A2%E5%BA%94%E7%94%A8%E5%92%8C%E5%A4%9A%E9%A1%B5%E9%9D%A2%E5%BA%94%E7%94%A8%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%8C%E4%BB%A5%E5%8F%8A%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-number">1.12.</span> <span class="toc-text">单页面应用和多页面应用的区别，以及使用场景</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%90%8E%E7%AB%AF%E5%9F%BA%E6%9C%AC%E7%9A%84%E5%87%A0%E4%B8%AA%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="toc-number">1.13.</span> <span class="toc-text">后端基本的几个数据结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8D%95%E7%82%B9%E7%99%BB%E5%BD%95"><span class="toc-number">1.14.</span> <span class="toc-text">单点登录</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E9%87%8F%E5%BA%9E%E5%A4%A7%E6%80%8E%E4%B9%88%E5%A4%84%E7%90%86"><span class="toc-number">1.15.</span> <span class="toc-text">数据量庞大怎么处理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%A7%E6%95%B0%E6%8D%AE%E7%9A%84%E8%AE%A1%E7%AE%97%E6%96%B9%E6%A1%88"><span class="toc-number">1.16.</span> <span class="toc-text">大数据的计算方案</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#WebWorker%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%8C%E6%80%8E%E4%B9%88%E7%94%A8"><span class="toc-number">1.16.1.</span> <span class="toc-text">WebWorker是什么，怎么用</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Vue%E9%A1%B9%E7%9B%AE%E5%AE%9E%E7%8E%B0%E8%A1%A8%E6%A0%BC%E6%8B%96%E6%8B%BD%E5%8A%9F%E8%83%BD"><span class="toc-number">1.17.</span> <span class="toc-text">Vue项目实现表格拖拽功能</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%89%8D%E7%AB%AF%E5%AF%B9%E4%BA%8E%E5%AE%89%E5%85%A8%E8%BF%99%E4%B8%80%E5%9D%97%E7%9A%84%E6%96%B9%E6%A1%88%E4%BB%A5%E5%8F%8A%E5%81%9A%E6%B3%95"><span class="toc-number">1.18.</span> <span class="toc-text">前端对于安全这一块的方案以及做法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Token%E5%8A%A0%E5%AF%86%E6%80%8E%E4%B9%88%E5%8A%A0%E5%AF%86%E7%9A%84%E7%94%A8%E7%9A%84%E4%BB%80%E4%B9%88%E6%8A%80%E6%9C%AF"><span class="toc-number">1.19.</span> <span class="toc-text">Token加密怎么加密的用的什么技术</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A1%86%E6%9E%B6%E5%92%8C%E5%BA%95%E5%B1%82%E4%BD%A0%E6%9C%89%E5%81%9A%E8%BF%87%E5%90%97%EF%BC%9F"><span class="toc-number">1.20.</span> <span class="toc-text">框架和底层你有做过吗？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%89%E5%B0%81%E8%A3%85%E8%BF%87%E7%BB%84%E4%BB%B6%E5%90%97%EF%BC%9F%E4%BB%80%E4%B9%88%E7%B1%BB%E5%9E%8B%E7%9A%84%EF%BC%9F"><span class="toc-number">1.21.</span> <span class="toc-text">有封装过组件吗？什么类型的？</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A1%A8%E6%A0%BC%E7%BB%84%E4%BB%B6%E7%9A%84%E5%B0%81%E8%A3%85%E5%8F%AF%E4%BB%A5%E4%BB%8E%E4%BB%A5%E4%B8%8B%E5%87%A0%E4%B8%AA%E6%96%B9%E9%9D%A2%E5%85%A5%E6%89%8B%EF%BC%9A"><span class="toc-number">1.21.1.</span> <span class="toc-text">表格组件的封装可以从以下几个方面入手：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A1%A8%E5%8D%95%E7%BB%84%E4%BB%B6%E7%9A%84%E5%B0%81%E8%A3%85%E5%8F%AF%E4%BB%A5%E4%BB%8E%E4%BB%A5%E4%B8%8B%E5%87%A0%E4%B8%AA%E6%96%B9%E9%9D%A2%E5%85%A5%E6%89%8B%EF%BC%9A"><span class="toc-number">1.21.2.</span> <span class="toc-text">表单组件的封装可以从以下几个方面入手：</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#elementui%E4%B8%8E%E6%83%B3%E8%A6%81%E7%9A%84%E6%95%88%E6%9E%9C%E4%B8%8D%E4%B8%80%E6%A0%B7%EF%BC%8C%E6%80%8E%E4%B9%88%E8%A7%A3%E5%86%B3%EF%BC%9F"><span class="toc-number">1.22.</span> <span class="toc-text">elementui与想要的效果不一样，怎么解决？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0"><span class="toc-number">1.23.</span> <span class="toc-text">文件上传</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%AD%E7%82%B9%E7%BB%AD%E4%BC%A0%E5%92%8C%E5%88%86%E7%89%87%E4%B8%8A%E4%BC%A0"><span class="toc-number">1.23.1.</span> <span class="toc-text">断点续传和分片上传</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%B9%E4%BA%8E%E7%94%A8%E6%88%B7%E8%BE%93%E5%85%A5%E7%9A%84%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8%E6%80%A7%E4%B8%BB%E8%A6%81%E4%BB%8E%E4%BB%A5%E4%B8%8B%E5%87%A0%E4%B8%AA%E6%96%B9%E9%9D%A2%E8%80%83%E8%99%91"><span class="toc-number">1.24.</span> <span class="toc-text">对于用户输入的信息安全性主要从以下几个方面考虑</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B5%8F%E8%A7%88%E5%99%A8"><span class="toc-number">2.</span> <span class="toc-text">浏览器</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#HTTP%E8%AF%B7%E6%B1%82%E7%A0%81%EF%BC%8C%E8%A7%A3%E9%87%8A%E4%B8%80%E4%B8%8B%E6%84%8F%E6%80%9D"><span class="toc-number">2.1.</span> <span class="toc-text">HTTP请求码，解释一下意思</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B5%8F%E8%A7%88%E5%99%A8%E6%98%AF%E6%80%8E%E4%B9%88%E6%B8%B2%E6%9F%93%E9%A1%B5%E9%9D%A2%E7%9A%84"><span class="toc-number">2.2.</span> <span class="toc-text">浏览器是怎么渲染页面的</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Keep-alive"><span class="toc-number">2.3.</span> <span class="toc-text">Keep alive</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#HTTP%E7%BC%93%E5%AD%98"><span class="toc-number">2.4.</span> <span class="toc-text">HTTP缓存</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BC%BA%E7%BC%93%E5%AD%98"><span class="toc-number">2.4.1.</span> <span class="toc-text">强缓存</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8D%8F%E5%95%86%E7%BC%93%E5%AD%98"><span class="toc-number">2.4.2.</span> <span class="toc-text">协商缓存</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%B5%84%E6%BA%90%E7%BC%93%E5%AD%98%E5%88%B0%E5%93%AA%E9%87%8C"><span class="toc-number">2.4.3.</span> <span class="toc-text">资源缓存到哪里</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BD%91%E5%9D%80%E7%AE%80%E5%8C%96"><span class="toc-number">2.5.</span> <span class="toc-text">网址简化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#HTTP%E5%92%8CHTTPS"><span class="toc-number">2.6.</span> <span class="toc-text">HTTP和HTTPS</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#SSL-TLS%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-number">2.7.</span> <span class="toc-text">SSL&#x2F;TLS是什么</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#HTTP%E5%8D%8F%E8%AE%AE"><span class="toc-number">2.8.</span> <span class="toc-text">HTTP协议</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#TCP-IP%E5%9F%BA%E6%9C%AC%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86"><span class="toc-number">2.9.</span> <span class="toc-text">TCP&#x2F;IP基本工作原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BE%93%E5%85%A5%E7%BD%91%E5%9D%80%E4%B9%8B%E5%90%8E%E5%8F%91%E7%94%9F%E4%BA%86%E4%BB%80%E4%B9%88"><span class="toc-number">2.10.</span> <span class="toc-text">输入网址之后发生了什么</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#TCP%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B"><span class="toc-number">2.11.</span> <span class="toc-text">TCP三次握手</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#TCP%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B"><span class="toc-number">2.12.</span> <span class="toc-text">TCP四次挥手</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A1%B5%E9%9D%A2%E6%95%B0%E6%8D%AE%E5%AE%9E%E6%97%B6%E5%88%B7%E6%96%B0"><span class="toc-number">2.13.</span> <span class="toc-text">页面数据实时刷新</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#WebSocket"><span class="toc-number">2.14.</span> <span class="toc-text">WebSocket</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%8E%E4%B9%88%E7%94%A8"><span class="toc-number">2.14.1.</span> <span class="toc-text">怎么用</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B5%8F%E8%A7%88%E5%99%A8%E8%AF%B7%E6%B1%82%E6%96%B9%E5%BC%8F"><span class="toc-number">2.15.</span> <span class="toc-text">浏览器请求方式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#GET%E5%92%8CPOST%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">2.15.1.</span> <span class="toc-text">GET和POST的区别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#GET%E5%92%8CPOST%E6%9C%89%E6%B2%A1%E6%9C%89%E7%BC%93%E5%AD%98"><span class="toc-number">2.15.2.</span> <span class="toc-text">GET和POST有没有缓存</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B7%A8%E5%9F%9F"><span class="toc-number">2.16.</span> <span class="toc-text">跨域</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E8%B7%A8%E5%9F%9F"><span class="toc-number">2.16.1.</span> <span class="toc-text">什么是跨域</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BC%9A%E5%BC%95%E8%B5%B7%E8%B7%A8%E5%9F%9F"><span class="toc-number">2.16.2.</span> <span class="toc-text">为什么会引起跨域</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%8E%E4%B9%88%E8%A7%A3%E5%86%B3%E8%B7%A8%E5%9F%9F"><span class="toc-number">2.16.3.</span> <span class="toc-text">怎么解决跨域</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%8D%E5%8A%A1%E7%AB%AF%E6%B8%B2%E6%9F%93%E8%B7%9F%E5%AE%A2%E6%88%B7%E7%AB%AF%E6%B8%B2%E6%9F%93%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%8C%E4%BC%98%E7%BC%BA%E7%82%B9%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-number">2.17.</span> <span class="toc-text">服务端渲染跟客户端渲染有什么区别，优缺点是什么</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6"><span class="toc-number">2.18.</span> <span class="toc-text">垃圾回收机制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B5%8F%E8%A7%88%E5%99%A8%E5%A6%82%E4%BD%95%E6%B8%B2%E6%9F%93%E9%A1%B5%E9%9D%A2"><span class="toc-number">2.19.</span> <span class="toc-text">浏览器如何渲染页面</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#localStorage%E3%80%81sessionStorage%E5%92%8CCookies%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">2.20.</span> <span class="toc-text">localStorage、sessionStorage和Cookies的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#JS%E8%B7%9FCSS%E4%BC%9A%E9%98%BB%E5%A1%9E%E7%BA%BF%E7%A8%8B%E5%90%97%EF%BC%9F%E4%B8%BA%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">2.21.</span> <span class="toc-text">JS跟CSS会阻塞线程吗？为什么？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Vue"><span class="toc-number">3.</span> <span class="toc-text">Vue</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Vue%E6%89%93%E5%8C%85%E5%8F%91%E5%B8%83%E6%B5%81%E7%A8%8B"><span class="toc-number">3.1.</span> <span class="toc-text">Vue打包发布流程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Vue%E6%89%93%E5%8C%85%E4%BD%93%E7%A7%AF%E8%BF%87%E5%A4%A7%E5%AF%BC%E8%87%B4%E9%A6%96%E5%B1%8F%E5%8A%A0%E8%BD%BD%E7%BC%93%E6%85%A2"><span class="toc-number">3.2.</span> <span class="toc-text">Vue打包体积过大导致首屏加载缓慢</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Vue%E9%A1%B9%E7%9B%AE%E4%B8%8A%E7%9A%84%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96"><span class="toc-number">3.3.</span> <span class="toc-text">Vue项目上的性能优化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Vue%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E5%8F%8A%E7%90%86%E8%A7%A3"><span class="toc-number">3.4.</span> <span class="toc-text">Vue的生命周期及理解</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A3%B0%E6%98%8E%E5%91%A8%E6%9C%9F%E7%9A%84%E4%BD%9C%E7%94%A8%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-number">3.5.</span> <span class="toc-text">声明周期的作用是什么</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%88%B6%E5%AD%90%E7%BB%84%E4%BB%B6%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F"><span class="toc-number">3.6.</span> <span class="toc-text">父子组件的生命周期执行顺序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%8C%E5%90%91%E6%95%B0%E6%8D%AE%E7%BB%91%E5%AE%9A%E5%8E%9F%E7%90%86"><span class="toc-number">3.7.</span> <span class="toc-text">双向数据绑定原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%99%9A%E6%8B%9FDOM%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="toc-number">3.8.</span> <span class="toc-text">虚拟DOM的作用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#diff%E7%AE%97%E6%B3%95"><span class="toc-number">3.9.</span> <span class="toc-text">diff算法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%9C%9F%E5%AE%9EDOM%E5%92%8C%E8%99%9A%E6%8B%9FDOM%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">3.10.</span> <span class="toc-text">真实DOM和虚拟DOM的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#render%E5%87%BD%E6%95%B0"><span class="toc-number">3.11.</span> <span class="toc-text">render函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#v-if%E5%92%8Cv-show%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">3.12.</span> <span class="toc-text">v-if和v-show的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#v-for%E8%B7%9Fv-if%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E8%83%BD%E4%B8%80%E8%B5%B7%E7%94%A8"><span class="toc-number">3.13.</span> <span class="toc-text">v-for跟v-if为什么不能一起用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Vue-js%E4%B8%BA%E4%BB%80%E4%B9%88%E9%87%87%E7%94%A8%E5%BC%82%E6%AD%A5%E6%B8%B2%E6%9F%93"><span class="toc-number">3.14.</span> <span class="toc-text">Vue.js为什么采用异步渲染</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Vue%E5%AE%9E%E7%8E%B0%E5%BC%BA%E5%88%B6%E5%88%B7%E6%96%B0"><span class="toc-number">3.15.</span> <span class="toc-text">Vue实现强制刷新</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#v-for%E4%B8%AD%E7%9A%84key%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="toc-number">3.16.</span> <span class="toc-text">v-for中的key的作用</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8index%E4%BD%9C%E4%B8%BAKey%E5%80%BC"><span class="toc-number">3.16.1.</span> <span class="toc-text">使用index作为Key值</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8C%87%E4%BB%A4"><span class="toc-number">3.17.</span> <span class="toc-text">自定义指令</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#computed%E5%92%8Cwatch%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">3.18.</span> <span class="toc-text">computed和watch的区别</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#watcher%E5%AE%9E%E4%BE%8B"><span class="toc-number">3.18.1.</span> <span class="toc-text">watcher实例</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%84%E4%BB%B6%E9%80%9A%E4%BF%A1"><span class="toc-number">3.19.</span> <span class="toc-text">组件通信</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#scoped%E6%A0%B7%E5%BC%8F%E9%9A%94%E7%A6%BB%E7%9A%84%E5%8E%9F%E7%90%86"><span class="toc-number">3.20.</span> <span class="toc-text">scoped样式隔离的原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Vue3%E4%BE%A6%E5%90%AC%E5%99%A8"><span class="toc-number">3.21.</span> <span class="toc-text">Vue3侦听器</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%89%A7%E8%A1%8C%E6%97%B6%E6%9C%BA"><span class="toc-number">3.21.1.</span> <span class="toc-text">执行时机</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Proxy%E5%8F%8C%E5%90%91%E6%95%B0%E6%8D%AE%E7%BB%91%E5%AE%9A%E7%9A%84%E5%8E%9F%E7%90%86"><span class="toc-number">3.22.</span> <span class="toc-text">Proxy双向数据绑定的原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Vue2%E5%8F%8C%E5%90%91%E7%BB%91%E5%AE%9A%E7%9A%84%E7%BC%BA%E9%99%B7"><span class="toc-number">3.23.</span> <span class="toc-text">Vue2双向绑定的缺陷</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Vue3%E5%92%8CVue2%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">3.24.</span> <span class="toc-text">Vue3和Vue2的区别</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%94%B9%E8%BF%9B%E4%BA%86v-model"><span class="toc-number">3.24.1.</span> <span class="toc-text">改进了v-model</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8v-model%E7%BB%91%E5%AE%9A%E8%87%AA%E5%AE%9A%E4%B9%89%E7%BB%84%E4%BB%B6%E6%97%B6%E8%87%AA%E5%AE%9A%E4%B9%89%E7%BB%84%E4%BB%B6%E4%B8%AD%E5%BA%94%E8%AF%A5%E5%81%9A%E4%BB%80%E4%B9%88"><span class="toc-number">3.24.2.</span> <span class="toc-text">使用v-model绑定自定义组件时自定义组件中应该做什么</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#V2%E5%92%8CV3%E5%8F%8C%E5%90%91%E6%95%B0%E6%8D%AE%E7%BB%91%E5%AE%9A%E5%8E%9F%E7%90%86%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">3.24.3.</span> <span class="toc-text">V2和V3双向数据绑定原理的区别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Composition-API"><span class="toc-number">3.24.4.</span> <span class="toc-text">Composition API</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Options-API"><span class="toc-number">3.24.5.</span> <span class="toc-text">Options API</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#nextTick%E5%8E%9F%E7%90%86"><span class="toc-number">3.25.</span> <span class="toc-text">$nextTick原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Ref"><span class="toc-number">3.26.</span> <span class="toc-text">Ref</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Vuex"><span class="toc-number">3.27.</span> <span class="toc-text">Vuex</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BC%98%E7%BC%BA%E7%82%B9"><span class="toc-number">3.27.1.</span> <span class="toc-text">优缺点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88Mutation-%E6%98%AF%E5%90%8C%E6%AD%A5%E7%9A%84%E8%80%8CAction%E6%98%AF%E5%BC%82%E6%AD%A5%E7%9A%84"><span class="toc-number">3.27.2.</span> <span class="toc-text">为什么Mutation 是同步的而Action是异步的</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%B7%E6%96%B0%E9%A1%B5%E9%9D%A2%E4%B9%8B%E5%90%8EVueX%E6%89%80%E7%AE%A1%E7%90%86%E7%9A%84%E6%95%B0%E6%8D%AE%E4%BC%9A%E4%B8%A2%E5%A4%B1%E6%80%8E%E4%B9%88%E8%A7%A3%E5%86%B3"><span class="toc-number">3.27.3.</span> <span class="toc-text">刷新页面之后VueX所管理的数据会丢失怎么解决</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Vuex%E5%92%8C%E6%9C%AC%E5%9C%B0%E5%AD%98%E5%82%A8%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">3.27.4.</span> <span class="toc-text">Vuex和本地存储的区别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Vuex%E5%AE%9A%E4%B9%89%E7%9A%84%E5%85%A8%E5%B1%80%E6%95%B0%E6%8D%AE%E8%B7%9F%E7%8A%B6%E6%80%81%E8%B7%9F%E6%88%91%E5%9C%A8main-js%E4%B8%AD%E5%AE%9A%E4%B9%89%E7%9A%84%E5%85%A8%E5%B1%80%E6%95%B0%E6%8D%AE%E5%92%8C%E7%8A%B6%E6%80%81%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB"><span class="toc-number">3.27.5.</span> <span class="toc-text">Vuex定义的全局数据跟状态跟我在main.js中定义的全局数据和状态有什么区别</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B7%AF%E7%94%B1"><span class="toc-number">3.28.</span> <span class="toc-text">路由</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#vue-router%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9Froute%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F%E6%9C%89%E4%BB%80%E4%B9%88%E7%BB%84%E4%BB%B6%EF%BC%9F"><span class="toc-number">3.28.1.</span> <span class="toc-text">vue-router是什么？route是什么？有什么组件？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%B7%AF%E7%94%B1%E7%9A%84%E5%8E%9F%E7%90%86"><span class="toc-number">3.28.2.</span> <span class="toc-text">路由的原理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E8%B7%AF%E7%94%B1"><span class="toc-number">3.28.3.</span> <span class="toc-text">动态路由</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9D%83%E9%99%90%E7%AE%A1%E7%90%86"><span class="toc-number">3.28.4.</span> <span class="toc-text">权限管理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%B7%AF%E7%94%B1%E5%AE%88%E5%8D%AB%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%8C%E5%B9%B2%E4%BB%80%E4%B9%88%E7%94%A8%E7%9A%84"><span class="toc-number">3.28.5.</span> <span class="toc-text">路由守卫有哪些，干什么用的</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%B7%AF%E7%94%B1%E7%BC%93%E5%AD%98"><span class="toc-number">3.28.6.</span> <span class="toc-text">路由缓存</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%B7%AF%E7%94%B1%E7%BC%93%E5%AD%98%E7%9A%84%E5%8E%9F%E7%90%86"><span class="toc-number">3.28.6.1.</span> <span class="toc-text">路由缓存的原理</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#hash%E5%92%8Chistory%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">3.28.7.</span> <span class="toc-text">hash和history的区别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%89%8D%E7%AB%AF%E6%A0%B9%E6%8D%AE%E8%A7%92%E8%89%B2%E6%9D%83%E9%99%90%E7%AE%A1%E7%90%86%E8%BF%9B%E8%A1%8C%E5%8A%A8%E6%80%81%E8%B7%AF%E7%94%B1%E4%B8%80%E8%88%AC%E6%98%AF%E5%9C%A8%E5%93%AA%E4%B8%80%E9%83%A8%E5%88%86%E8%BF%9B%E8%A1%8C%E5%A4%84%E7%90%86%E7%9A%84"><span class="toc-number">3.28.8.</span> <span class="toc-text">前端根据角色权限管理进行动态路由一般是在哪一部分进行处理的</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%B7%AF%E7%94%B1%E4%BC%A0%E5%8F%82%E7%9A%84%E4%B8%A4%E7%A7%8D%E6%96%B9%E5%BC%8F%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">3.28.9.</span> <span class="toc-text">路由传参的两种方式的区别</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%A0%E5%AF%B9%E7%BB%84%E4%BB%B6%E7%9A%84%E7%90%86%E8%A7%A3"><span class="toc-number">3.29.</span> <span class="toc-text">你对组件的理解</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B0%81%E8%A3%85Vue%E7%BB%84%E4%BB%B6%E7%9A%84%E6%97%B6%E5%80%99%E5%BA%94%E8%AF%A5%E8%80%83%E8%99%91%E5%93%AA%E4%BA%9B%E6%96%B9%E9%9D%A2"><span class="toc-number">3.30.</span> <span class="toc-text">封装Vue组件的时候应该考虑哪些方面</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%88%B6%E7%BB%84%E4%BB%B6%E8%B0%83%E7%94%A8%E5%AD%90%E7%BB%84%E4%BB%B6-%E5%AD%90%E8%B0%83%E7%88%B6"><span class="toc-number">3.31.</span> <span class="toc-text">父组件调用子组件,子调父</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#npm-install-%E5%AE%89%E8%A3%85%E5%8C%85%E6%97%B6%EF%BC%8C%E5%B8%B8%E7%94%A8%E7%9A%84-S-%E3%80%81-D-%E3%80%81-g-%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">3.32.</span> <span class="toc-text">npm install 安装包时，常用的-S 、-D 、-g 有什么区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Axios"><span class="toc-number">3.33.</span> <span class="toc-text">Axios</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8B%A6%E6%88%AA%E5%99%A8%E4%B8%AD%E5%8F%AF%E4%BB%A5%E5%81%9A%E4%BB%80%E4%B9%88%E6%93%8D%E4%BD%9C"><span class="toc-number">3.33.1.</span> <span class="toc-text">拦截器中可以做什么操作</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Ajax%E5%92%8CAxios%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">3.33.2.</span> <span class="toc-text">Ajax和Axios的区别</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Pinia"><span class="toc-number">3.34.</span> <span class="toc-text">Pinia</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E4%BD%BF%E7%94%A8pinia"><span class="toc-number">3.34.1.</span> <span class="toc-text">为什么要使用pinia</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Pinia%E5%92%8CVueX%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">3.34.2.</span> <span class="toc-text">Pinia和VueX的区别</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#uniapp"><span class="toc-number">4.</span> <span class="toc-text">uniapp</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B0%8F%E7%A8%8B%E5%BA%8F%E9%A1%B5%E9%9D%A2%E4%B9%8B%E9%97%B4%E9%80%9A%E4%BF%A1%E6%9C%89%E5%87%A0%E7%A7%8D%E6%96%B9%E5%BC%8F"><span class="toc-number">4.1.</span> <span class="toc-text">小程序页面之间通信有几种方式</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#jQuery"><span class="toc-number">5.</span> <span class="toc-text">jQuery</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#jQuery%E5%8A%A8%E6%80%81%E7%BB%91%E5%AE%9A%E4%BA%8B%E4%BB%B6"><span class="toc-number">5.1.</span> <span class="toc-text">jQuery动态绑定事件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#jquery%E8%8E%B7%E5%8F%96dom%E5%AF%B9%E8%B1%A1%E6%98%AF%E4%B8%80%E4%B8%AA%E4%BB%80%E4%B9%88%E6%A0%B7%E7%9A%84%E4%B8%9C%E8%A5%BF%EF%BC%8C%E6%80%8E%E4%B9%88%E9%81%8D%E5%8E%86%EF%BC%9F"><span class="toc-number">5.2.</span> <span class="toc-text">jquery获取dom对象是一个什么样的东西，怎么遍历？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#jquery%E7%BB%99%E5%85%83%E7%B4%A0%E6%B7%BB%E5%8A%A0%E7%B1%BB%E5%90%8D%EF%BC%8C%E8%87%AA%E5%AE%9A%E4%B9%89%E5%B1%9E%E6%80%A7"><span class="toc-number">5.3.</span> <span class="toc-text">jquery给元素添加类名，自定义属性</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ES6"><span class="toc-number">6.</span> <span class="toc-text">ES6</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#var%E3%80%81let%E5%92%8Cconst%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">6.1.</span> <span class="toc-text">var、let和const的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ES6%E6%9C%89%E5%93%AA%E4%BA%9B%E9%81%8D%E5%8E%86%E6%95%B0%E7%BB%84%E7%9A%84%E6%96%B9%E6%B3%95"><span class="toc-number">6.2.</span> <span class="toc-text">ES6有哪些遍历数组的方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AE%AD%E5%A4%B4%E5%87%BD%E6%95%B0%E8%83%BD%E4%B8%8D%E8%83%BDnew"><span class="toc-number">6.3.</span> <span class="toc-text">箭头函数能不能new</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#forin%E5%92%8Cforof%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">6.4.</span> <span class="toc-text">forin和forof的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Promise%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">6.5.</span> <span class="toc-text">Promise是什么？</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%82%E6%95%B0"><span class="toc-number">6.5.1.</span> <span class="toc-text">参数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Promise-all%E5%92%8CPromise-allSettled"><span class="toc-number">6.5.2.</span> <span class="toc-text">Promise.all和Promise.allSettled</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8C%BA%E5%88%AB"><span class="toc-number">6.5.3.</span> <span class="toc-text">区别</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#async%E5%92%8Cawait%E5%92%8Cpromise%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">6.6.</span> <span class="toc-text">async和await和promise的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#map%E5%92%8CforEach%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">6.7.</span> <span class="toc-text">map和forEach的区别</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#HTML"><span class="toc-number">7.</span> <span class="toc-text">HTML</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A1%8C%E7%BA%A7%E5%85%83%E7%B4%A0%EF%BC%8C%E5%9D%97%E7%BA%A7%E5%85%83%E7%B4%A0%EF%BC%8C%E8%A1%8C%E5%86%85%E5%9D%97%E5%85%83%E7%B4%A0"><span class="toc-number">7.1.</span> <span class="toc-text">行级元素，块级元素，行内块元素</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9B%9E%E6%B5%81%E5%92%8C%E9%87%8D%E7%BB%98"><span class="toc-number">7.2.</span> <span class="toc-text">回流和重绘</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#DOM%E4%BA%8B%E4%BB%B6%E6%B5%81%E7%9A%84%E6%95%B4%E4%B8%AA%E6%B5%81%E7%A8%8B"><span class="toc-number">7.3.</span> <span class="toc-text">DOM事件流的整个流程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Doctype%E4%BD%9C%E7%94%A8"><span class="toc-number">7.4.</span> <span class="toc-text">Doctype作用</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#CSS"><span class="toc-number">8.</span> <span class="toc-text">CSS</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AE%80%E5%8D%95%E8%AF%B4%E4%B8%80%E4%B8%8B%E7%9B%92%E5%AD%90%E6%A8%A1%E5%9E%8B%EF%BC%8C%E4%BB%A5%E5%8F%8A%E6%A0%87%E5%87%86%E6%83%85%E5%86%B5%E5%92%8CIE%E6%83%85%E5%86%B5%E4%B8%8B%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">8.1.</span> <span class="toc-text">简单说一下盒子模型，以及标准情况和IE情况下的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%89%E6%A0%8F%E5%B8%83%E5%B1%80%E7%9A%84%E6%96%B9%E6%A1%88"><span class="toc-number">8.2.</span> <span class="toc-text">三栏布局的方案</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#CSS%E5%B0%BA%E5%AF%B8%E8%AE%BE%E7%BD%AE%E7%9A%84%E5%8D%95%E4%BD%8D"><span class="toc-number">8.3.</span> <span class="toc-text">CSS尺寸设置的单位</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#css%E9%9A%90%E8%97%8F%E5%85%83%E7%B4%A0%E7%9A%84%E6%96%B9%E6%B3%95"><span class="toc-number">8.4.</span> <span class="toc-text">css隐藏元素的方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#height%E5%92%8Cline-height%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">8.5.</span> <span class="toc-text">height和line-height的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#calc-%E5%87%BD%E6%95%B0"><span class="toc-number">8.6.</span> <span class="toc-text">calc()函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%83%E7%B4%A0%E5%9E%82%E7%9B%B4%E6%B0%B4%E5%B9%B3%E5%B1%85%E4%B8%AD%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E5%BC%8F"><span class="toc-number">8.7.</span> <span class="toc-text">元素垂直水平居中的几种方式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%B7%E5%BC%8F%E4%BC%98%E5%85%88%E7%BA%A7%E7%9A%84%E8%A7%84%E5%88%99%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-number">8.8.</span> <span class="toc-text">样式优先级的规则是什么</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#BFC"><span class="toc-number">8.9.</span> <span class="toc-text">BFC</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#margin%E5%A1%8C%E9%99%B7%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88"><span class="toc-number">8.10.</span> <span class="toc-text">margin塌陷解决方案</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B8%90%E5%8F%98"><span class="toc-number">8.11.</span> <span class="toc-text">渐变</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BA%BF%E6%80%A7%E6%B8%90%E5%8F%98"><span class="toc-number">8.11.1.</span> <span class="toc-text">线性渐变</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%A2%9C%E8%89%B2%E7%BB%88%E6%AD%A2%E4%BD%8D%E7%BD%AE"><span class="toc-number">8.11.2.</span> <span class="toc-text">颜色终止位置</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%93%8D%E5%BA%94%E5%BC%8F%E5%B8%83%E5%B1%80%E6%96%B9%E6%A1%88"><span class="toc-number">8.12.</span> <span class="toc-text">响应式布局方案</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9A%E4%BD%8D%E7%9A%84%E5%B1%9E%E6%80%A7"><span class="toc-number">8.13.</span> <span class="toc-text">定位的属性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#flex%E7%BB%99%E5%AD%90%E5%85%83%E7%B4%A0%E5%86%99flex%EF%BC%9A1%E4%BB%80%E4%B9%88%E6%84%8F%E6%80%9D%EF%BC%9F"><span class="toc-number">8.14.</span> <span class="toc-text">flex给子元素写flex：1什么意思？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%8E%E4%B9%88%E6%A0%B7%E6%B8%85%E9%99%A4%E6%B5%AE%E5%8A%A8%EF%BC%9F"><span class="toc-number">8.15.</span> <span class="toc-text">怎么样清除浮动？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8E%9F%E7%94%9FJS"><span class="toc-number">9.</span> <span class="toc-text">原生JS</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#JS%E7%9A%84%E4%B8%A5%E6%A0%BC%E6%A8%A1%E5%BC%8F"><span class="toc-number">9.1.</span> <span class="toc-text">JS的严格模式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%99%AE%E9%80%9A%E5%87%BD%E6%95%B0%E8%B7%9F%E7%AE%AD%E5%A4%B4%E5%87%BD%E6%95%B0%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">9.2.</span> <span class="toc-text">普通函数跟箭头函数的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%92%8C-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">9.3.</span> <span class="toc-text">&#x3D;&#x3D;和&#x3D;&#x3D;&#x3D;的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#null%E5%92%8Cundefined%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">9.4.</span> <span class="toc-text">null和undefined的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B7%B1%E6%8B%B7%E8%B4%9D%EF%BC%8C%E6%B5%85%E6%8B%B7%E8%B4%9D"><span class="toc-number">9.5.</span> <span class="toc-text">深拷贝，浅拷贝</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0%E6%B7%B1%E6%8B%B7%E8%B4%9D%E6%96%B9%E6%B3%95"><span class="toc-number">9.5.1.</span> <span class="toc-text">实现深拷贝方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0%E6%B5%85%E6%8B%B7%E8%B4%9D%E6%96%B9%E6%B3%95"><span class="toc-number">9.5.2.</span> <span class="toc-text">实现浅拷贝方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-number">9.5.3.</span> <span class="toc-text">应用场景</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#call-%E3%80%81-apply-%E5%92%8Cbind-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">9.6.</span> <span class="toc-text">.call()、.apply()和bind()的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%97%AD%E5%8C%85%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%8C%E6%9C%89%E4%BB%80%E4%B9%88%E7%89%B9%E6%80%A7%EF%BC%8C%E5%AF%B9%E9%A1%B5%E9%9D%A2%E6%9C%89%E4%BB%80%E4%B9%88%E5%BD%B1%E5%93%8D"><span class="toc-number">9.7.</span> <span class="toc-text">闭包是什么，有什么特性，对页面有什么影响</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%97%AD%E5%8C%85%E7%9A%84%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-number">9.7.1.</span> <span class="toc-text">闭包的使用场景</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F"><span class="toc-number">9.8.</span> <span class="toc-text">内存泄漏</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95"><span class="toc-number">9.8.1.</span> <span class="toc-text">解决方法</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%A4%E6%96%AD%E5%8F%98%E9%87%8F%E7%B1%BB%E5%9E%8B%E7%9A%84%E6%96%B9%E6%B3%95"><span class="toc-number">9.9.</span> <span class="toc-text">判断变量类型的方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#JS%E7%BB%A7%E6%89%BF%E7%9A%84%E6%96%B9%E6%B3%95%E5%92%8C%E4%BC%98%E7%BC%BA%E7%82%B9"><span class="toc-number">9.10.</span> <span class="toc-text">JS继承的方法和优缺点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#JS%E5%AE%9E%E7%8E%B0%E5%BC%82%E6%AD%A5%E7%9A%84%E6%96%B9%E6%B3%95"><span class="toc-number">9.11.</span> <span class="toc-text">JS实现异步的方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%92%E6%B3%A1%E5%92%8C%E6%8D%95%E8%8E%B7"><span class="toc-number">9.12.</span> <span class="toc-text">冒泡和捕获</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%9C%E7%94%A8%E5%9F%9F"><span class="toc-number">9.13.</span> <span class="toc-text">作用域</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%9C%E7%94%A8%E5%9F%9F%E9%93%BE"><span class="toc-number">9.14.</span> <span class="toc-text">作用域链</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%98%B2%E6%8A%96%E5%92%8C%E8%8A%82%E6%B5%81"><span class="toc-number">9.15.</span> <span class="toc-text">防抖和节流</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#new%E6%93%8D%E4%BD%9C%E7%AC%A6%E5%81%9A%E4%BA%86%E4%BB%80%E4%B9%88"><span class="toc-number">9.16.</span> <span class="toc-text">new操作符做了什么</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%93%8D%E4%BD%9CCookie"><span class="toc-number">9.17.</span> <span class="toc-text">操作Cookie</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%8F%E4%BB%BB%E5%8A%A1%E5%92%8C%E5%BE%AE%E4%BB%BB%E5%8A%A1"><span class="toc-number">9.18.</span> <span class="toc-text">宏任务和微任务</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F%EF%BC%9A"><span class="toc-number">9.18.1.</span> <span class="toc-text">执行顺序：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%8F%E4%BB%BB%E5%8A%A1%E5%92%8C%E5%BE%AE%E4%BB%BB%E5%8A%A1%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F"><span class="toc-number">9.18.2.</span> <span class="toc-text">宏任务和微任务有哪些？</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#addeventlister-%E6%96%B9%E6%B3%95%E5%8F%82%E6%95%B0%E4%B8%AD%E7%9A%84%E5%87%BD%E6%95%B0%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E8%83%BD%E6%98%AF%E5%8C%BF%E5%90%8D%E5%87%BD%E6%95%B0"><span class="toc-number">9.19.</span> <span class="toc-text">addeventlister()方法参数中的函数为什么不能是匿名函数</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B0%8F%E7%A8%8B%E5%BA%8F"><span class="toc-number">10.</span> <span class="toc-text">小程序</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><span class="toc-number">10.1.</span> <span class="toc-text">生命周期</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B7%AF%E7%94%B1%E8%B7%B3%E8%BD%ACAPI"><span class="toc-number">10.2.</span> <span class="toc-text">路由跳转API</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8C%BA%E5%88%AB-1"><span class="toc-number">10.2.1.</span> <span class="toc-text">区别</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B0%8F%E7%A8%8B%E5%BA%8F%E7%99%BB%E5%BD%95%E6%B5%81%E7%A8%8B"><span class="toc-number">10.3.</span> <span class="toc-text">小程序登录流程</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#TypeScript"><span class="toc-number">11.</span> <span class="toc-text">TypeScript</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#JavaScript%E5%92%8CTypeScript%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">11.1.</span> <span class="toc-text">JavaScript和TypeScript的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B3%9B%E5%9E%8B"><span class="toc-number">11.2.</span> <span class="toc-text">泛型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8E%A5%E5%8F%A3"><span class="toc-number">11.3.</span> <span class="toc-text">接口</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#react"><span class="toc-number">12.</span> <span class="toc-text">react</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Hook"><span class="toc-number">12.1.</span> <span class="toc-text">Hook</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/07/21/vuecli%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%90%AD%E5%BB%BA/" title="vuecli的基本搭建">vuecli的基本搭建</a><time datetime="2023-07-21T04:08:30.000Z" title="发表于 2023-07-21 12:08:30">2023-07-21</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/07/21/Jequery%E4%BD%BF%E7%94%A8/" title="Jequery使用">Jequery使用</a><time datetime="2023-07-21T04:04:58.000Z" title="发表于 2023-07-21 12:04:58">2023-07-21</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/07/21/%E5%89%8D%E7%AB%AF%E4%B8%89%E5%89%91%E5%AE%A2%E7%AC%94%E8%AE%B0/" title="前端三剑客笔记">前端三剑客笔记</a><time datetime="2023-07-21T03:56:10.000Z" title="发表于 2023-07-21 11:56:10">2023-07-21</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/07/21/git%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/" title="git的基本操作">git的基本操作</a><time datetime="2023-07-21T03:52:14.000Z" title="发表于 2023-07-21 11:52:14">2023-07-21</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/07/20/%E9%9D%A2%E8%AF%95%E9%A2%98/" title="前端面试题">前端面试题</a><time datetime="2023-07-20T15:18:42.000Z" title="发表于 2023-07-20 23:18:42">2023-07-20</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2023 By sssc</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.umd.min.js"></script><div class="js-pjax"></div><script async data-pjax src="/js/sky.js"></script><div class="aplayer no-destroy" data-id="8967031835" data-server="tencent" data-type="playlist" data-fixed="true" data-autoplay="true" data-lrcType="-1"> </div><script defer="defer" id="ribbon" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-ribbon.min.js" size="150" alpha="0.6" zIndex="-1" mobile="false" data-click="true"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/activate-power-mode.min.js"></script><script>POWERMODE.colorful = true;
POWERMODE.shake = true;
POWERMODE.mobile = false;
document.body.addEventListener('input', POWERMODE);
</script><script id="click-show-text" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/click-show-text.min.js" data-mobile="false" data-text="$,￥" data-fontsize="15px" data-random="false" async="async"></script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/metingjs/dist/Meting.min.js"></script><script src="https://cdn.jsdelivr.net/npm/pjax/pjax.min.js"></script><script>let pjaxSelectors = ["head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]

var pjax = new Pjax({
  elements: 'a:not([target="_blank"])',
  selectors: pjaxSelectors,
  cacheBust: false,
  analytics: false,
  scrollRestoration: false
})

document.addEventListener('pjax:send', function () {

  // removeEventListener scroll 
  window.tocScrollFn && window.removeEventListener('scroll', window.tocScrollFn)
  window.scrollCollect && window.removeEventListener('scroll', scrollCollect)

  document.getElementById('rightside').style.cssText = "opacity: ''; transform: ''"
  
  if (window.aplayers) {
    for (let i = 0; i < window.aplayers.length; i++) {
      if (!window.aplayers[i].options.fixed) {
        window.aplayers[i].destroy()
      }
    }
  }

  typeof typed === 'object' && typed.destroy()

  //reset readmode
  const $bodyClassList = document.body.classList
  $bodyClassList.contains('read-mode') && $bodyClassList.remove('read-mode')

  typeof disqusjs === 'object' && disqusjs.destroy()
})

document.addEventListener('pjax:complete', function () {
  window.refreshFn()

  document.querySelectorAll('script[data-pjax]').forEach(item => {
    const newScript = document.createElement('script')
    const content = item.text || item.textContent || item.innerHTML || ""
    Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
    newScript.appendChild(document.createTextNode(content))
    item.parentNode.replaceChild(newScript, item)
  })

  GLOBAL_CONFIG.islazyload && window.lazyLoadInstance.update()

  typeof panguInit === 'function' && panguInit()

  // google analytics
  typeof gtag === 'function' && gtag('config', '', {'page_path': window.location.pathname});

  // baidu analytics
  typeof _hmt === 'object' && _hmt.push(['_trackPageview',window.location.pathname]);

  typeof loadMeting === 'function' && document.getElementsByClassName('aplayer').length && loadMeting()

  // prismjs
  typeof Prism === 'object' && Prism.highlightAll()
})

document.addEventListener('pjax:error', (e) => {
  if (e.request.status === 404) {
    pjax.loadUrl('/404.html')
  }
})</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div class="no-result" id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js"></script></div></div>
        <style>
            [bg-lazy] {
                background-image: none !important;
                background-color: #eee !important;
            }
        </style>
        <script>
            window.imageLazyLoadSetting = {
                isSPA: false,
                preloadRatio: 1,
                processImages: null,
            };
        </script><script>window.addEventListener("load",function(){var t=/\.(gif|jpg|jpeg|tiff|png)$/i,r=/^data:image\/[a-z]+;base64,/;Array.prototype.slice.call(document.querySelectorAll("img[data-original]")).forEach(function(a){var e=a.parentNode;"A"===e.tagName&&(e.href.match(t)||e.href.match(r))&&(e.href=a.dataset.original)})});</script><script>!function(r){r.imageLazyLoadSetting.processImages=t;var e=r.imageLazyLoadSetting.isSPA,n=r.imageLazyLoadSetting.preloadRatio||1,c=a();function a(){var t=Array.prototype.slice.call(document.querySelectorAll("img[data-original]")),e=Array.prototype.slice.call(document.querySelectorAll("[bg-lazy]"));return t.concat(e)}function t(){e&&(c=a());for(var t,o=0;o<c.length;o++)0<=(t=(t=c[o]).getBoundingClientRect()).bottom&&0<=t.left&&t.top<=(r.innerHeight*n||document.documentElement.clientHeight*n)&&function(){var t,e,n,a,i=c[o];e=function(){c=c.filter(function(t){return i!==t}),r.imageLazyLoadSetting.onImageLoaded&&r.imageLazyLoadSetting.onImageLoaded(i)},(t=i).hasAttribute("bg-lazy")?(t.removeAttribute("bg-lazy"),e&&e()):(n=new Image,a=t.getAttribute("data-original"),n.onload=function(){t.src=a,t.removeAttribute("data-original"),e&&e()},t.src!==a&&(n.src=a))}()}function i(){clearTimeout(t.tId),t.tId=setTimeout(t,500)}t(),document.addEventListener("scroll",i),r.addEventListener("resize",i),r.addEventListener("orientationchange",i)}(this);</script></body></html>